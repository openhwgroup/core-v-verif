(VRV32I Control Transfer Instructions
p0
ccopy_reg
_reconstructor
p1
(cvp_pack
Ip
p2
c__builtin__
object
p3
Ntp4
Rp5
(dp6
Vprop_count
p7
I8
sVname
p8
g0
sVprop_list
p9
(dp10
sVip_num
p11
I2
sVwid_order
p12
I2
sVrfu_dict
p13
(dp14
sVrfu_list
p15
(lp16
(V000_JAL
p17
g1
(cvp_pack
Prop
p18
g3
Ntp19
Rp20
(dp21
Vitem_count
p22
I3
sg8
g17
sVtag
p23
VVP_IP002_P000
p24
sVitem_list
p25
(dp26
sg12
I0
sg15
(lp27
(V000
p28
g1
(cvp_pack
Item
p29
g3
Ntp30
Rp31
(dp32
g8
V000
p33
sg23
VVP_IP002_P000_I000
p34
sVdescription
p35
Vjal rd, imm[20:1]\u000ard = pc+4; pc += Sext({imm[20:1], 1\u2019b0})\u000apc is calculated using signed arithmetic\u000a\u000ajal x0, imm[20:1] (special case: unconditional jump)\u000apc += Sext({imm[20:1], 1\u2019b0})
p36
sVpurpose
p37
VISA\u000aChapter 2.5
p38
sVverif_goals
p39
VRegister operands:\u000a\u000aAll possible rd registers are used.
p40
sVcoverage_loc
p41
Visacov.rv32i_jal_cg.cp_rd
p42
sVpfc
p43
I3
sVtest_type
p44
I3
sVcov_method
p45
I1
sVcores
p46
I56
sVcomments
p47
V
p48
sVstatus
p49
g48
sVsimu_target_list
p50
(lp51
sg15
(lp52
sVrfu_list_2
p53
(lp54
sg13
(dp55
Vlock_status
p56
I0
ssbtp57
a(V001
p58
g1
(g29
g3
Ntp59
Rp60
(dp61
g8
V001
p62
sg23
VVP_IP002_P000_I001
p63
sg35
Vjal rd, imm[20:1]\u000ard = pc+4; pc += Sext({imm[20:1], 1\u2019b0})\u000apc is calculated using signed arithmetic\u000a\u000ajal x0, imm[20:1] (special case: unconditional jump)\u000apc += Sext({imm[20:1], 1\u2019b0})
p64
sg37
VISA\u000aChapter 2.5
p65
sg39
VInput operands:\u000a\u000aimmj value is +ve, -ve, and zero\u000aAll bits of immj are toggled
p66
sg41
Visacov.rv32i_jal_cg.cp_immj_value\u000aisacov.rv32i_jal_cg.cp_immj_toggle
p67
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp68
sg15
(lp69
sg53
(lp70
sg13
(dp71
g56
I0
ssbtp72
a(V002
p73
g1
(g29
g3
Ntp74
Rp75
(dp76
g8
V002
p77
sg23
VVP_IP002_P000_I002
p78
sg35
Vjal rd, imm[20:1]\u000ard = pc+4; pc += Sext({imm[20:1], 1\u2019b0})\u000apc is calculated using signed arithmetic\u000a\u000ajal x0, imm[20:1] (special case: unconditional jump)\u000apc += Sext({imm[20:1], 1\u2019b0})
p79
sg37
VISA\u000aChapter 2.5
p80
sg39
VOutput result:\u000a\u000aAll bits of rd are toggled
p81
sg41
Visacov.rv32i_jal_cg.cp_rd_toggle
p82
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp83
sg15
(lp84
sg53
(lp85
sg13
(dp86
g56
I0
ssbtp87
asVrfu_list_1
p88
(lp89
sg53
(lp90
sg13
(dp91
sbtp92
a(V001_JALR
p93
g1
(g18
g3
Ntp94
Rp95
(dp96
g22
I3
sg8
g93
sg23
VVP_IP002_P001
p97
sg25
(dp98
sg12
I1
sg15
(lp99
(V000
p100
g1
(g29
g3
Ntp101
Rp102
(dp103
g8
V000
p104
sg23
VVP_IP002_P001_I000
p105
sg35
Vjalr rd, rs1, imm[11:0]\u000ard = pc+4; pc = rs1 + Sext(imm[11:0])\u000apc is calculated using signed arithmetic
p106
sg37
VISA\u000aChapter 2.5
p107
sg39
VRegister operands:\u000a\u000aAll possible rs1 registers are used.\u000aAll possible rd registers are used.\u000aAll possible register combinations where rs1 == rd are used
p108
sg41
Visacov.rv32i_jalr_cg.cp_rs1\u000aisacov.rv32i_jalr_cg.cp_rd\u000aisacov.rv32i_jalr_cg.cp_rd_rs1_hazard
p109
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp110
sg15
(lp111
sg53
(lp112
sg13
(dp113
g56
I0
ssbtp114
a(V001
p115
g1
(g29
g3
Ntp116
Rp117
(dp118
g8
V001
p119
sg23
VVP_IP002_P001_I001
p120
sg35
Vjalr rd, rs1, imm[11:0]\u000ard = pc+4; pc = rs1 + Sext(imm[11:0])\u000apc is calculated using signed arithmetic
p121
sg37
VISA\u000aChapter 2.5
p122
sg39
VInput operands:\u000a\u000aimmi value is +ve, -ve, and zero\u000aAll bits of immi are toggled\u000aAll bits of rs1 are toggled
p123
sg41
Visacov.rv32i_jalr_cg.cp_immi_value\u000aisacov.rv32i_jalr_cg.cp_immi_toggle\u000aisacov.rv32i_jalr_cg.cp_rs1_toggle
p124
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp125
sg15
(lp126
sg53
(lp127
sg13
(dp128
g56
I0
ssbtp129
a(V002
p130
g1
(g29
g3
Ntp131
Rp132
(dp133
g8
V002
p134
sg23
VVP_IP002_P001_I002
p135
sg35
Vjalr rd, rs1, imm[11:0]\u000ard = pc+4; pc = rs1 + Sext(imm[11:0])\u000apc is calculated using signed arithmetic
p136
sg37
VISA\u000aChapter 2.5
p137
sg39
VOutput result:\u000a\u000aAll bits of rd are toggled
p138
sg41
Visacov.rv32i_jalr_cg.cp_rd_toggle
p139
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp140
sg15
(lp141
sg53
(lp142
sg13
(dp143
g56
I0
ssbtp144
asg88
(lp145
sg53
(lp146
sg13
(dp147
sbtp148
a(V002_BEQ
p149
g1
(g18
g3
Ntp150
Rp151
(dp152
g22
I3
sg8
g149
sg23
VVP_IP002_P002
p153
sg25
(dp154
sg12
I2
sg15
(lp155
(V000
p156
g1
(g29
g3
Ntp157
Rp158
(dp159
g8
V000
p160
sg23
VVP_IP002_P002_I000
p161
sg35
Vbeq rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1==rs2) else pc += 4\u000apc is calculated using signed arithmetic
p162
sg37
VISA\u000aChapter 2.5
p163
sg39
VRegister operands:\u000a\u000aAll possible rs1 registers are used.\u000aAll possible rs2 registers are used.
p164
sg41
Visacov.rv32i_beq_cg.cp_rs1\u000aisacov.rv32i_beq_cg.cp_rs2
p165
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp166
sg15
(lp167
sg53
(lp168
sg13
(dp169
g56
I0
ssbtp170
a(V001
p171
g1
(g29
g3
Ntp172
Rp173
(dp174
g8
V001
p175
sg23
VVP_IP002_P002_I001
p176
sg35
Vbeq rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1==rs2) else pc += 4\u000apc is calculated using signed arithmetic
p177
sg37
VISA\u000aChapter 2.5
p178
sg39
VInput operands:\u000a\u000aimmb value is +ve, -ve, and zero\u000aAll bits of immb are toggled\u000aAll bits of rs1 are toggled\u000aAll bits of rs2 are toggled
p179
sg41
Visacov.rv32i_beq_cg.cp_immb_value\u000aisacov.rv32i_beq_cg.cp_rs1_toggle\u000aisacov.rv32i_beq_cg.cp_rs2_toggle
p180
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp181
sg15
(lp182
sg53
(lp183
sg13
(dp184
g56
I0
ssbtp185
a(V002
p186
g1
(g29
g3
Ntp187
Rp188
(dp189
g8
V002
p190
sg23
VVP_IP002_P002_I002
p191
sg35
Vbeq rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1==rs2) else pc += 4\u000apc is calculated using signed arithmetic
p192
sg37
VISA\u000aChapter 2.5
p193
sg39
VOutput result:\u000a\u000aBranch taken or not-taken
p194
sg41
Visacov.rv32i_beq_cg.cp_branch_taken
p195
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp196
sg15
(lp197
sg53
(lp198
sg13
(dp199
g56
I0
ssbtp200
asg88
(lp201
sg53
(lp202
sg13
(dp203
sbtp204
a(V003_BNE
p205
g1
(g18
g3
Ntp206
Rp207
(dp208
g22
I3
sg8
g205
sg23
VVP_IP002_P003
p209
sg25
(dp210
sg12
I3
sg15
(lp211
(V000
p212
g1
(g29
g3
Ntp213
Rp214
(dp215
g8
V000
p216
sg23
VVP_IP002_P003_I000
p217
sg35
Vbne rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1!=rs2) else pc += 4\u000apc is calculated using signed arithmetic
p218
sg37
VISA\u000aChapter 2.5
p219
sg39
VRegister operands:\u000a\u000aAll possible rs1 registers are used.\u000aAll possible rs2 registers are used.
p220
sg41
Visacov.rv32i_bne_cg.cp_rs1\u000aisacov.rv32i_bne_cg.cp_rs2
p221
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp222
sg15
(lp223
sg53
(lp224
sg13
(dp225
g56
I0
ssbtp226
a(V001
p227
g1
(g29
g3
Ntp228
Rp229
(dp230
g8
V001
p231
sg23
VVP_IP002_P003_I001
p232
sg35
Vbne rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1!=rs2) else pc += 4\u000apc is calculated using signed arithmetic
p233
sg37
VISA\u000aChapter 2.5
p234
sg39
VInput operands:\u000a\u000aimmb value is +ve, -ve, and zero\u000aAll bits of immb are toggled\u000aAll bits of rs1 are toggled\u000aAll bits of rs2 are toggled
p235
sg41
Visacov.rv32i_bne_cg.cp_immb_value\u000aisacov.rv32i_bne_cg.cp_rs1_toggle\u000aisacov.rv32i_bne_cg.cp_rs2_toggle
p236
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp237
sg15
(lp238
sg53
(lp239
sg13
(dp240
g56
I0
ssbtp241
a(V002
p242
g1
(g29
g3
Ntp243
Rp244
(dp245
g8
V002
p246
sg23
VVP_IP002_P003_I002
p247
sg35
Vbne rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1!=rs2) else pc += 4\u000apc is calculated using signed arithmetic
p248
sg37
VISA\u000aChapter 2.5
p249
sg39
VOutput result:\u000a\u000aBranch taken or not-taken
p250
sg41
Visacov.rv32i_bne_cg.cp_branch_taken
p251
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp252
sg15
(lp253
sg53
(lp254
sg13
(dp255
g56
I0
ssbtp256
asg88
(lp257
sg53
(lp258
sg13
(dp259
sbtp260
a(V004_BLT
p261
g1
(g18
g3
Ntp262
Rp263
(dp264
g22
I3
sg8
g261
sg23
VVP_IP002_P004
p265
sg25
(dp266
sg12
I4
sg15
(lp267
(V000
p268
g1
(g29
g3
Ntp269
Rp270
(dp271
g8
V000
p272
sg23
VVP_IP002_P004_I000
p273
sg35
Vblt rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 < rs2) else pc += 4\u000apc is calculated using signed arithmetic
p274
sg37
VISA\u000aChapter 2.5
p275
sg39
VRegister operands:\u000a\u000aAll possible rs1 registers are used.\u000aAll possible rs2 registers are used.
p276
sg41
Visacov.rv32i_blt_cg.cp_rs1\u000aisacov.rv32i_blt_cg.cp_rs2
p277
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp278
sg15
(lp279
sg53
(lp280
sg13
(dp281
g56
I0
ssbtp282
a(V001
p283
g1
(g29
g3
Ntp284
Rp285
(dp286
g8
V001
p287
sg23
VVP_IP002_P004_I001
p288
sg35
Vblt rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 < rs2) else pc += 4\u000apc is calculated using signed arithmetic
p289
sg37
VISA\u000aChapter 2.5
p290
sg39
VInput operands:\u000a\u000aimmb value is +ve, -ve, and zero\u000aAll bits of immb are toggled\u000aAll bits of rs1 are toggled\u000aAll bits of rs2 are toggled
p291
sg41
Visacov.rv32i_blt_cg.cp_immb_value\u000aisacov.rv32i_blt_cg.cp_rs1_toggle\u000aisacov.rv32i_blt_cg.cp_rs2_toggle
p292
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp293
sg15
(lp294
sg53
(lp295
sg13
(dp296
g56
I0
ssbtp297
a(V002
p298
g1
(g29
g3
Ntp299
Rp300
(dp301
g8
V002
p302
sg23
VVP_IP002_P004_I002
p303
sg35
Vblt rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 < rs2) else pc += 4\u000apc is calculated using signed arithmetic
p304
sg37
VISA\u000aChapter 2.5
p305
sg39
VOutput result:\u000a\u000aBranch taken or not-taken
p306
sg41
Visacov.rv32i_blt_cg.cp_branch_taken
p307
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp308
sg15
(lp309
sg53
(lp310
sg13
(dp311
g56
I0
ssbtp312
asg88
(lp313
sg53
(lp314
sg13
(dp315
sbtp316
a(V005_BGE
p317
g1
(g18
g3
Ntp318
Rp319
(dp320
g22
I6
sg8
g317
sg23
VVP_IP002_P005
p321
sg25
(dp322
sg12
I5
sg15
(lp323
(V000
p324
g1
(g29
g3
Ntp325
Rp326
(dp327
g8
V000
p328
sg23
VVP_IP002_P005_I000
p329
sg35
Vbge rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 >= rs2) else pc += 4\u000apc is calculated using signed arithmetic
p330
sg37
VISA\u000aChapter 2.5
p331
sg39
VRegister operands:\u000a\u000aAll possible rs1 registers are used.\u000aAll possible rs2 registers are used.
p332
sg41
Visacov.rv32i_bge_cg.cp_rs1\u000aisacov.rv32i_bge_cg.cp_rs2
p333
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp334
sg15
(lp335
sg53
(lp336
sg13
(dp337
g56
I0
ssbtp338
a(V001
p339
g1
(g29
g3
Ntp340
Rp341
(dp342
g8
g339
sg23
VVP_IP002_P005_I001
p343
sg35
Vbge rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 >= rs2) else pc += 4\u000apc is calculated using signed arithmetic
p344
sg37
VISA\u000aChapter 2.5
p345
sg39
VInput operands:\u000a\u000aimmb value is +ve, -ve, and zero\u000aAll bits of immb are toggled\u000aAll bits of rs1 are toggled\u000aAll bits of rs2 are toggled
p346
sg41
Visacov.rv32i_bge_cg.cp_immb_value\u000aisacov.rv32i_bge_cg.cp_rs1_toggle\u000aisacov.rv32i_bge_cg.cp_rs2_toggle
p347
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp348
sg15
(lp349
sg53
(lp350
sg13
(dp351
g56
I0
ssbtp352
a(V002
p353
g1
(g29
g3
Ntp354
Rp355
(dp356
g8
g353
sg23
VVP_IP002_P005_I002
p357
sg35
Vbge rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 >= rs2) else pc += 4\u000apc is calculated using signed arithmetic
p358
sg37
VISA\u000aChapter 2.5
p359
sg39
VOutput result:\u000a\u000aBranch taken or not-taken
p360
sg41
Visacov.rv32i_bge_cg.cp_branch_taken
p361
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp362
sg15
(lp363
sg53
(lp364
sg13
(dp365
g56
I0
ssbtp366
asg88
(lp367
sg53
(lp368
sg13
(dp369
sbtp370
a(V006_BLTU
p371
g1
(g18
g3
Ntp372
Rp373
(dp374
g22
I3
sg8
g371
sg23
VVP_IP002_P006
p375
sg25
(dp376
sg12
I6
sg15
(lp377
(V000
p378
g1
(g29
g3
Ntp379
Rp380
(dp381
g8
V000
p382
sg23
VVP_IP002_P006_I000
p383
sg35
Vbltu rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 < rs2) else pc += 4\u000apc is calculated using unsigned arithmetic
p384
sg37
VISA\u000aChapter 2.5
p385
sg39
VRegister operands:\u000a\u000aAll possible rs1 registers are used.\u000aAll possible rs2 registers are used.
p386
sg41
Visacov.rv32i_bltu_cg.cp_rs1\u000aisacov.rv32i_bltu_cg.cp_rs2
p387
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp388
sg15
(lp389
sg53
(lp390
sg13
(dp391
g56
I0
ssbtp392
a(V001
p393
g1
(g29
g3
Ntp394
Rp395
(dp396
g8
V001
p397
sg23
VVP_IP002_P006_I001
p398
sg35
Vbltu rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 < rs2) else pc += 4\u000apc is calculated using unsigned arithmetic
p399
sg37
VISA\u000aChapter 2.5
p400
sg39
VInput operands:\u000a\u000aimmb value is +ve, -ve, and zero\u000aAll bits of immb are toggled\u000aAll bits of rs1 are toggled\u000aAll bits of rs2 are toggled
p401
sg41
Visacov.rv32i_bltu_cg.cp_immb_value\u000aisacov.rv32i_bltu_cg.cp_rs1_toggle\u000aisacov.rv32i_bltu_cg.cp_rs2_toggle
p402
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp403
sg15
(lp404
sg53
(lp405
sg13
(dp406
g56
I0
ssbtp407
a(V002
p408
g1
(g29
g3
Ntp409
Rp410
(dp411
g8
V002
p412
sg23
VVP_IP002_P006_I002
p413
sg35
Vbltu rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 < rs2) else pc += 4\u000apc is calculated using unsigned arithmetic
p414
sg37
VISA\u000aChapter 2.5
p415
sg39
VOutput result:\u000a\u000aBranch taken or not-taken
p416
sg41
Visacov.rv32i_bltu_cg.cp_branch_taken
p417
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp418
sg15
(lp419
sg53
(lp420
sg13
(dp421
g56
I0
ssbtp422
asg88
(lp423
sg53
(lp424
sg13
(dp425
sbtp426
a(V007_BGEU
p427
g1
(g18
g3
Ntp428
Rp429
(dp430
g22
I3
sg8
g427
sg23
VVP_IP002_P007
p431
sg25
(dp432
sg12
I7
sg15
(lp433
(V000
p434
g1
(g29
g3
Ntp435
Rp436
(dp437
g8
V000
p438
sg23
VVP_IP002_P007_I000
p439
sg35
Vbgeu rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 >= rs2) else pc += 4\u000apc is calculated using unsigned arithmetic
p440
sg37
VISA\u000aChapter 2.5
p441
sg39
VRegister operands:\u000a\u000aAll possible rs1 registers are used.\u000aAll possible rs2 registers are used.
p442
sg41
Visacov.rv32i_bgeu_cg.cp_rs1\u000aisacov.rv32i_bgeu_cg.cp_rs2
p443
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp444
sg15
(lp445
sg53
(lp446
sg13
(dp447
g56
I0
ssbtp448
a(V001
p449
g1
(g29
g3
Ntp450
Rp451
(dp452
g8
V001
p453
sg23
VVP_IP002_P007_I001
p454
sg35
Vbgeu rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 >= rs2) else pc += 4\u000apc is calculated using unsigned arithmetic
p455
sg37
VISA\u000aChapter 2.5
p456
sg39
VInput operands:\u000a\u000aimmb value is +ve, -ve, and zero\u000aAll bits of immb are toggled\u000aAll bits of rs1 are toggled\u000aAll bits of rs2 are toggled
p457
sg41
Visacov.rv32i_bgeu_cg.cp_immb_value\u000aisacov.rv32i_bgeu_cg.cp_rs1_toggle\u000aisacov.rv32i_bgeu_cg.cp_rs2_toggle
p458
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp459
sg15
(lp460
sg53
(lp461
sg13
(dp462
g56
I0
ssbtp463
a(V002
p464
g1
(g29
g3
Ntp465
Rp466
(dp467
g8
V002
p468
sg23
VVP_IP002_P007_I002
p469
sg35
Vbgeu rs1, rs2, imm[12:1]\u000apc += Sext({imm[12:1], 1\u2019b0}) if (rs1 >= rs2) else pc += 4\u000apc is calculated using unsigned arithmetic
p470
sg37
VISA\u000aChapter 2.5
p471
sg39
VOutput result:\u000a\u000aBranch taken or not-taken
p472
sg41
Visacov.rv32i_bgeu_cg.cp_branch_taken
p473
sg43
I3
sg44
I3
sg45
I1
sg46
I56
sg47
g48
sg49
g48
sg50
(lp474
sg15
(lp475
sg53
(lp476
sg13
(dp477
g56
I0
ssbtp478
asg88
(lp479
sg53
(lp480
sg13
(dp481
sbtp482
asVrfu_list_0
p483
(lp484
sg88
(lp485
sVvptool_gitrev
p486
V$Id$
p487
sbtp488
.