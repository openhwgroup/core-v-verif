diff --git a/vendor/riscv/riscv-isa-sim/riscv/Proc.cc b/vendor/riscv/riscv-isa-sim/riscv/Proc.cc
index c3d4149..ce0078c 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Proc.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/Proc.cc
@@ -20,15 +20,23 @@ st_rvfi Processor::step(size_t n, st_rvfi reference) {
   this->taken_trap = false;
   this->which_trap = 0;
 
-  rvfi.pc_rdata = this->get_state()->pc;
+  // Store the state before stepping
+  state_t prev_state = *this->get_state();
+
   processor_t::step(n);
 
+  rvfi.pc_rdata = this->last_pc;
+
+  rvfi.pc_wdata = this->get_state()->pc; // Next predicted PC
+
   rvfi.mode = this->get_state()->last_inst_priv;
   rvfi.insn =
       (uint32_t)(this->get_state()->last_inst_fetched.bits() & 0xffffffffULL);
 
   // TODO FIXME Handle multiple/zero writes in a single insn.
   auto &reg_commits = this->get_state()->log_reg_write;
+  auto &mem_write_commits = this->get_state()->log_mem_write;
+  auto &mem_read_commits = this->get_state()->log_mem_read;
   int xlen = this->get_state()->last_inst_xlen;
   int flen = this->get_state()->last_inst_flen;
 
@@ -37,13 +45,69 @@ st_rvfi Processor::step(size_t n, st_rvfi reference) {
   rvfi.rs2_addr = this->get_state()->last_inst_fetched.rs2();
   // TODO add rs2_value
 
-  rvfi.trap = this->taken_trap;
-  rvfi.trap |= (this->which_trap << 1);
 
+  if(this->next_rvfi_intr){
+    rvfi.intr = next_rvfi_intr;
+    this->next_rvfi_intr = 0;
+
+  }
+  
+  // Output dbg caused from EBREAK the previous instruction
+  if(this->next_debug) {
+    rvfi.dbg = this->next_debug;
+    this->next_debug = 0;
+  }
+
+  if(this->state.debug_mode  && (prev_state.debug_mode == 0)){
+    // New external debug request
+    if((this->halt_request != HR_NONE)){ 
+      rvfi.dbg = this->get_state()->dcsr->cause;
+      rvfi.dbg_mode = 1;
+
+    // EBREAK
+    } else if(this->get_state()->dcsr->cause == DCSR_CAUSE_SWBP) {
+      // EBREAK will set debug_mode to 1, but we should report this at the next instruction
+      rvfi.trap |= 1 << 0; //trap [0]
+      rvfi.trap |= 1 << 2; //debug [2]
+      rvfi.trap |= 0xE00 & ((DCSR_CAUSE_SWBP) << 9); //debug cause [11:9]
+      
+      this->next_debug = DCSR_CAUSE_SWBP;
+    }
+  }
+
+  // Set dbg_mode to 1 the first instruction in debug mode, but delay turning 
+  // off dbg_mode to the next instruction after turning off to keep dbg_mode on for dret
+  if( (this->halt_request != HR_NONE)  && (prev_state.debug_mode == 0)) {
+    rvfi.dbg_mode = 1;
+  } else {
+    rvfi.dbg_mode = prev_state.debug_mode;
+  }
+
+
+  if(this->taken_trap) {
+    //interrrupts are marked with the msb high in which_trap
+    if(this->which_trap & ((reg_t)1 << (isa->get_max_xlen() - 1))) { 
+      //Since spike steps two times to take an interrupt, we store the intr value to the next step to return with rvfi
+      this->next_rvfi_intr |= 1 << 0; //intr [0]
+      this->next_rvfi_intr |= 1 << 2; //interrupt [2]
+      this->next_rvfi_intr |= 0x3FF8 & ((this->which_trap & 0xFF) << 3); //cause[13:3]
+    } else{
+      rvfi.trap |= 1 << 0; //trap [0]
+      rvfi.trap |= 1 << 1; //exception [1]
+      rvfi.trap |= 0x1F8 & ((this->which_trap) << 3); //exception_cause [8:3]
+      //TODO:
+      //debug_cause     [11:9] debug cause
+      //cause_type      [13:12]
+      //clicptr         [14]  CLIC interrupt pending
+      this->next_rvfi_intr = rvfi.trap; //store value to return with rvfi.intr on the next step
+    }
+  }
+
+  uint64_t last_rd_addr = 0;
+  uint64_t last_rd_wdata = 0;
   bool got_commit = false;
   for (auto &reg : reg_commits) {
-      if ((reg.first >> 4) > 32) {
-          if ((reg.first >> 4) < 0xFFF) {
+    if((reg.first & 0xf) == 0x4) { //If CSR
             for (size_t i = 0; i < CSR_SIZE; i++) {
                 if (!rvfi.csr_valid[i]) {
                     rvfi.csr_valid[i] = 1;
@@ -54,14 +118,59 @@ st_rvfi Processor::step(size_t n, st_rvfi reference) {
                 }
             }
           }
+    else {
+      if (got_commit) {
+        last_rd_addr = reg.first >> 4;
+        last_rd_wdata = reg.second.v[0];
+        continue;
       }
-      else {
         // TODO FIXME Take into account the XLEN/FLEN for int/FP values.
         rvfi.rd1_addr = reg.first >> 4;
         rvfi.rd1_wdata = reg.second.v[0];
         // TODO FIXME Handle multiple register commits per cycle.
         // TODO FIXME This must be handled on the RVFI side as well.
+      got_commit = true; // Only latch first commit
+    }
+  }
+  // popret(z) should return rd1_addr = 0 instead of the SP to match with the cv32e40s core
+  if (((this->get_state()->last_inst_fetched.bits() & MASK_CM_POPRET) == MATCH_CM_POPRET) ||
+      ((this->get_state()->last_inst_fetched.bits() & MASK_CM_POPRETZ) == MATCH_CM_POPRETZ)) {
+    rvfi.rd1_addr = 0;
+    rvfi.rd1_wdata = 0;
+  }
+
+  bool mem_access = false; // TODO: support multiple memory writes/reads
+  int read_len;
+  for (auto &mem : mem_read_commits) {
+    //mem format: (addr, 0, size) (value is not stored for reads, but should be the same as rd)
+    if(!mem_access) {
+      rvfi.mem_addr = std::get<0>(mem);
+      if ((this->get_state()->last_inst_fetched.bits() & MASK_CM_POP) == MATCH_CM_POP         ||
+          (this->get_state()->last_inst_fetched.bits() & MASK_CM_POPRET) == MATCH_CM_POPRET   ||
+          (this->get_state()->last_inst_fetched.bits() & MASK_CM_POPRETZ) == MATCH_CM_POPRETZ ){    
+        rvfi.mem_rdata = last_rd_wdata; // During pop, rd1 returns sp, so instead return value read from memory 
+      } else {
+        rvfi.mem_rdata = rvfi.rd1_wdata; 
       }
+      //mem_rmask should hold a bitmask of which bytes in mem_rdata contain valid data
+      read_len = std::get<2>(mem);
+      rvfi.mem_rmask = (1 << read_len) - 1;
+      mem_access = true;
+    }
+  }
+
+  int write_len;
+  for (auto &mem : mem_write_commits) {
+    //mem format: (addr, value, size)
+    if(!mem_access) {
+      rvfi.mem_addr = std::get<0>(mem);
+      rvfi.mem_wdata = std::get<1>(mem); // value
+      //mem_wmask should hold a bitmask of which bytes in mem_wdata contain valid data
+      write_len = std::get<2>(mem);
+      rvfi.mem_wmask = (1 << write_len) - 1;
+      mem_access = true;
+    }
+
   }
 
   if (csr_counters_injection) {
@@ -107,6 +216,12 @@ Processor::Processor(
   Params::parse_params(base, this->params, params);
 
   string isa_str = this->params[base + "isa"].a_string;
+
+  // Add _xdummy to enable bit 23 in MISA if non standard extensions are used
+  if( (this->params[base+"nonstd_ext"]).a_bool) {
+    isa_str = isa_str + "_xdummy";
+  }
+
   string priv_str = this->params[base + "priv"].a_string;
   std::cout << "[SPIKE] Proc 0 | ISA: " << isa_str << " PRIV: " << priv_str << std::endl;
   this->isa =
@@ -192,6 +307,9 @@ Processor::Processor(
   bool misa_we = (this->params[base + "misa_we"]).a_bool;
   if (misa_we_enable)
     this->state.misa->set_we(misa_we);
+
+  this->next_rvfi_intr = 0;
+
 }
 
 void Processor::take_trap(trap_t &t, reg_t epc) {
@@ -242,6 +360,10 @@ void Processor::default_params(string base, openhw::Params &params) {
 
   params.set_bool(base, "csr_counters_injection", false, "false",
              "Allow to set CSRs getting values from a DPI");
+
+  params.set_bool(base, "nonstd_ext", false, "false",
+             "Non-standard extension used");
+
 }
 
 inline void Processor::set_XPR(reg_t num, reg_t value) {
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Proc.h b/vendor/riscv/riscv-isa-sim/riscv/Proc.h
index 5387ce1..12533f2 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Proc.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/Proc.h
@@ -21,7 +21,8 @@ public:
 protected:
   bool csr_counters_injection;
   bool taken_trap;
-  uint8_t which_trap;
+  uint32_t which_trap;
+  reg_t next_rvfi_intr, next_debug;
   virtual void take_trap(trap_t &t, reg_t epc); // take an exception
 };
 
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc b/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc
index 551ce79..946268e 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc
@@ -52,6 +52,18 @@ void Simulation::default_params(openhw::Params &params) {
   params.set_uint64_t("/top/", "dram_size", 0x400UL * 1024 * 1024,
              "0x40000000", "DRAM size");
 
+  params.set_bool("/top/", "dbg", false, "false", "DBG enable");
+  params.set_uint64_t("/top/", "dbg_base", 0x1a110800UL,
+             "0x80000000", "DBG base address");
+  params.set_uint64_t("/top/", "dbg_size", 0x1000UL,
+             "0x40000000", "DBG size");
+
+  params.set_bool("/top/", "vp", false, "false", "Virtual peripherals enable");
+  params.set_uint64_t("/top/", "vp_base", 0x00800000UL,
+             "0x80000000", "VP base address");
+  params.set_uint64_t("/top/", "vp_size", 0x1000UL,
+             "0x40000000", "VP size");
+
   params.set_bool("/top/", "log_commits", true, "True",
              "Log commit enable");
 
@@ -60,6 +72,9 @@ void Simulation::default_params(openhw::Params &params) {
   params.set_uint64_t("/top/", "max_steps", 200000UL, "200000",
              "Maximum steps that the simulation can do ");
 
+  params.set_bool("/top/", "dtb_enabled", true, "True",
+             "dtb_enabled");
+
   Processor::default_params("/top/cores/", params);
 }
 
@@ -115,7 +130,7 @@ Simulation::Simulation(const cfg_t *cfg, string elf_path,
                  plugin_devs, std::vector<std::string>() = {elf_path},
                  dm_config,
                  "tandem.log", // log_path
-                 true,         // dtb_enabled
+                 (params["/top/dtb_enabled"]).a_bool, // dtb_enabled
                  nullptr,      // dtb_file
                  false,        // socket_enabled
                  NULL,         // cmd_file
@@ -175,6 +190,25 @@ void Simulation::make_mems(const std::vector<mem_cfg_t> &layout) {
   if (dram) {
     this->mems.push_back(std::make_pair(dram_base, new mem_t(dram_size)));
   }
+
+  //dbg
+  bool dbg = (this->params["/top/dbg"]).a_bool;
+  uint64_t dbg_base = (this->params["/top/dbg_base"]).a_uint64_t;
+  uint64_t dbg_size = (this->params["/top/dbg_size"]).a_uint64_t;
+  if (dbg){
+    this->mems.push_back(std::make_pair(dbg_base, new mem_t(dbg_size)));
+  }
+
+
+  //CV_VP_REGISTER 
+  bool vp = (this->params["/top/vp"]).a_bool;
+  uint64_t vp_base = (this->params["/top/vp_base"]).a_uint64_t;
+  uint64_t vp_size = (this->params["/top/vp_size"]).a_uint64_t;
+  if (vp) {
+    this->mems.push_back(std::make_pair(vp_base, new mem_t(vp_size)));
+  }
+
+  
 }
 
 std::vector<st_rvfi> Simulation::step(size_t n,
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Types.h b/vendor/riscv/riscv-isa-sim/riscv/Types.h
index d0b953f..496df0e 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Types.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/Types.h
@@ -28,8 +28,7 @@ typedef struct {
    uint64_t                 insn_interrupt;
    uint64_t                 insn_interrupt_id;
    uint64_t                 insn_bus_fault;
-   uint64_t                 insn_nmi_store_fault;
-   uint64_t                 insn_nmi_load_fault;
+   uint64_t                 insn_nmi_cause;
 
    uint64_t                 pc_rdata;
    uint64_t                 pc_wdata;
diff --git a/vendor/riscv/riscv-isa-sim/riscv/csrs.cc b/vendor/riscv/riscv-isa-sim/riscv/csrs.cc
index f71e61f..28695eb 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/csrs.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/csrs.cc
@@ -992,13 +992,15 @@ bool wide_counter_csr_t::unlogged_write(const reg_t val) noexcept {
   // takes precedence over the increment to instret.  However, Spike
   // unconditionally increments instret after executing an instruction.
   // Correct for this artifact by decrementing instret here.
-   openhw::reg::unlogged_write( openhw::reg::unlogged_read()-1);
+
+  // disable since we (at the moment) check mcounterinhibit
+  //openhw::reg::unlogged_write( openhw::reg::unlogged_read()-1);
   return true;
 }
 
 reg_t wide_counter_csr_t::written_value() const noexcept {
   // Re-adjust for upcoming bump()
-  return  openhw::reg::unlogged_read() + 1;
+  return  openhw::reg::unlogged_read(); //+ 1; // Disable since we dont always bump
 }
 
 // implement class time_counter_csr_t
@@ -1239,9 +1241,10 @@ reg_t dcsr_csr_t::read() const noexcept {
   v = set_field(v, DCSR_EBREAKH, ebreakh);
   v = set_field(v, DCSR_EBREAKS, ebreaks);
   v = set_field(v, DCSR_EBREAKU, ebreaku);
-  v = set_field(v, DCSR_STOPCYCLE, 0);
+  v = set_field(v, DCSR_STOPCYCLE, 1); //TODO: Make configurable
   v = set_field(v, DCSR_STOPTIME, 0);
   v = set_field(v, DCSR_CAUSE, cause);
+  v = set_field(v, DCSR_MPRVEN, 1); // TODO: Make configurable
   v = set_field(v, DCSR_STEP, step);
   v = set_field(v, DCSR_PRV, prv);
   return v;
diff --git a/vendor/riscv/riscv-isa-sim/riscv/debug_rom_defines.h b/vendor/riscv/riscv-isa-sim/riscv/debug_rom_defines.h
index 616cf59..d10e86b 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/debug_rom_defines.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/debug_rom_defines.h
@@ -17,7 +17,7 @@
 
 // These needs to match the link.ld         
 #define DEBUG_ROM_WHERETO 0x300
-#define DEBUG_ROM_ENTRY   0x800
+#define DEBUG_ROM_ENTRY   0x1A110800 //TODO: make configurable
 #define DEBUG_ROM_TVEC    0x808
 
 #endif
diff --git a/vendor/riscv/riscv-isa-sim/riscv/encoding.h b/vendor/riscv/riscv-isa-sim/riscv/encoding.h
index 48cb5c0..44cf70e 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/encoding.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/encoding.h
@@ -87,6 +87,7 @@
 #define DCSR_STOPTIME       (1<<9)
 #define DCSR_CAUSE          (7<<6)
 #define DCSR_DEBUGINT       (1<<5)
+#define DCSR_MPRVEN         (1<<4)
 #define DCSR_HALT           (1<<3)
 #define DCSR_STEP           (1<<2)
 #define DCSR_PRV            (3<<0)
diff --git a/vendor/riscv/riscv-isa-sim/riscv/execute.cc b/vendor/riscv/riscv-isa-sim/riscv/execute.cc
index 02b27c5..d922857 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/execute.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/execute.cc
@@ -342,10 +342,14 @@ void processor_t::step(size_t n)
       in_wfi = true;
     }
 
+    if(!(this->get_csr(CSR_MCOUNTINHIBIT) & 0x4)) {
     state.minstret->bump(instret);
+    }
 
     // Model a hart whose CPI is 1.
+    if(!(this->get_csr(CSR_MCOUNTINHIBIT) & 0x1)) {
     state.mcycle->bump(instret);
+    }
 
     n -= instret;
   }
diff --git a/vendor/riscv/riscv-isa-sim/riscv/riscv_dpi.cc b/vendor/riscv/riscv-isa-sim/riscv/riscv_dpi.cc
index 3222fc9..873b4bd 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/riscv_dpi.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/riscv_dpi.cc
@@ -51,6 +51,38 @@ extern "C" void spike_set_default_params(const char *profile) {
     params.set_string("/top/core/0/", "name", std::string("cva6"));
     params.set_string("/top/core/0/", "isa", std::string("RV64GC"));
   }
+  else if (strcmp(profile, "cv32e40s") == 0)
+  {
+    params.set_string("/top/", "isa", std::string("RV32I"));
+    params.set_string("/top/", "priv", std::string("MU"));
+    params.set_uint64_t("/top/", "num_procs", 0x1UL);
+    params.set_bool("/top/", "bootrom", false);
+    params.set_bool("/top/", "generic_core_config", true);
+    params.set_uint64_t("/top/", "dram_base", 0x00000000UL);
+    params.set_uint64_t("/top/", "dram_size", 0x400000UL);
+    params.set_bool("/top/", "max_steps_enabled", false);
+    params.set_uint64_t("/top/", "max_steps", 2000000UL);
+    params.set_bool("/top/", "dtb_enabled", false);
+
+
+    params.set_bool("/top/", "dbg", true);
+    params.set_uint64_t("/top/", "dbg_base", 0x1a110800UL);
+    params.set_uint64_t("/top/", "dbg_size", 0x1000UL);
+
+    //Virtual peripherals
+    params.set_bool("/top/", "vp", true);
+    params.set_uint64_t("/top/", "vp_base", 0x00800000UL);
+    params.set_uint64_t("/top/", "vp_size", 0x1000UL);
+
+
+    params.set_string("/top/core/0/", "name", std::string("cv32e40s"));
+    params.set_string("/top/core/0/", "isa", std::string("RV32I"));
+
+    params.set_uint64_t("/top/core/0/", "marchid", 0x15UL);
+    params.set_uint64_t("/top/core/0/", "misa", 0x40901104UL);
+    params.set_uint64_t("/top/core/0/", "mvendorid", 0x602UL);
+    params.set_uint64_t("/top/core/0/", "mcountinhibit", 0x5UL);
+  }
 }
 
 extern "C" void spike_set_param_uint64_t(const char *base, const char *name,
