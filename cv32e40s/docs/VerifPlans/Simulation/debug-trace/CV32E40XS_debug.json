[
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Debug mode can be entered by executing the EBREAK or C.EBREAK instruction when dcsr.ebreakm = 1\ncause = 1\n\n40S, same is true for \"dcsr.ebreaku\".",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\n\nEnsure exception routine is not enterred",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\" \ntc: mmode_ebreak_executes_debug_code",
        "Review (Marton)": "?",
        "Review (Robin)": "Are Lee's corner cases handled in this vplan?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\n\nEnsure exception routine is not enterred",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_execute_with_ebreakm\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_execute_with_ebreakm\nA  :uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA: uvmt_cv32_tb.u_debug_assert.dcsr_cause",
        "Review (Marton)": "?",
        "Review (Robin)": "Is Mike's gh issue handled in this vplan?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Debug mode can be entered by executing the EBREAK or C.EBREAK instruction when dcsr.ebreakm = 1\ncause = 1\n\n40S, same is true for \"dcsr.ebreaku\".\n",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary exception code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: exception_enters_debug_mode",
        "Review (Marton)": "?",
        "Review (Robin)": "Is the PMA overrule handled in this vplan?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary exception code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A: Hard to detect that we are executing an exception handler.\nCovered in debug_test with ISS enabled.\nA: uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA: uvmt_cv32_tb.u_debug_assert.dcsr_cause",
        "Review (Marton)": "?",
        "Review (Robin)": "Note: From OE about counters, \"vi burde ogs\u00e5 ha assert som sjekker at vi IKKE teller n\u00e5 countinhibit, sleep, eller stopcount... de assertionene jeg har endre sjekker bare at de teller... vet du om vi har andre sjekker p\u00e5 dette?\"",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter ebreak exception",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Enter ebreak exception routine when calling EBREAK or C.EBREAK when dcsr.ebreakm == 0.\n\n40S, same is true for \"dcsr.ebreaku\".",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code while ebreakm/u==0.\n\nVerify that:\nCore does not switch to debug mode, but exception routine is entered as normal.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: ebreak_behavior_m_mode",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[ebreakm=1?]\""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Enter ebreak exception",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code while ebreakm/u==0.\n\nVerify that:\nCore does not switch to debug mode, but exception routine is entered as normal.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_execute_without_ebreakm (ebreak_regular_nodebug)\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_execute_without_ebreakm (cebreak_regular_nodebug)\nA: uvmt_cv32_tb.u_debug_assert.a_ebreak_umode_exception\nA: uvmt_cv32_tb.u_debug_assert.a.ebreak_mmode_exception",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[ebreakm=1?]\""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter ebreak exception during single stepping",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Enter ebreak exception routine when calling EBREAK or C.EBREAK when dcsr.ebreakm == 0.\n\n40S, same is true for \"dcsr.ebreaku\".",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary single stepping code\n\nVerify that:\nCore switches into debug mode.\nDPC set to handler.\nDebug cause must be step (unless something else happened simultaneously).\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_known_miscompares\"",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[ebreakm=1?]\""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Enter ebreak exception during single stepping",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary single stepping code\n\nVerify that:\nCore switches into debug mode.\nDPC set to handler.\nDebug cause must be step (unless something else happened simultaneously).\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_execute_without_ebreakm (ebreak_step_nodebug)\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_execute_without_ebreakm (cebreak_step_nodebug)\n\nA: uvmt_cv32_tb.u_debug_assert.a_ebreak_umode_exception\nA: uvmt_cv32_tb.u_debug_assert.a.ebreak_mmode_exception",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[ebreakm=1?]\""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "External debug event",
        "Feature Description": "Debug mode can be entered by asserting the external signal debug_req_i\ncause is set to = 3 (also see verification goal)",
        "Verification Goal": "Assert debug_req_i while executing arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=debugger(0x3))\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: request_hw_debugger",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Assert debug_req_i while executing arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=debugger(0x3))\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_ext\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_mode_pc\nA: uvmt_cv32_tb.u_debug_assert.a_dpc_dbg_haltreq\nA: uvmt_cv32_tb.u_debug_assert.a_debug_req_taken",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac\n\nRISCV-V External Debug Support Version 0.13.2",
        "Requirement Location": "Debug chapter \n\n\n\nChapter 5",
        "Feature": "Trigger module",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "The core contains a trigger module with a configurable number of trigger register capable of triggering on i.a. instruction address match.\nSelect mcontrol6 for a trigger and enable instruction matching\nWrite breakpoint addr to tdata2 register\ncause = 2",
        "Verification Goal": "Verify that core enters debug mode when the trigger matches on instruction address. NB! According to spec, the tdataN registers can only be written from debug mode, as m-mode writes are ignored.\n\nEnter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and enable breakpoint in tdata1[2]\nExit debug mode (dret instruction)\nVerify that core enters debug mode on breakpoint addr\nCurrent PC is saved to DPC\nCause of debug must be saved to DCSR (cause=2)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_trigger\"",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Verify that core enters debug mode when the trigger matches on instruction address. NB! According to spec, the tdataN registers can only be written from debug mode, as m-mode writes are ignored.\n\nEnter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and enable breakpoint in tdata1[2]\nExit debug mode (dret instruction)\nVerify that core enters debug mode on breakpoint addr\nCurrent PC is saved to DPC\nCause of debug must be saved to DCSR (cause=2)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_trigger_match\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause\nA:  uvmt_cv32_tb.u_debug_assert.a_dpc_dbg_trigger\nA:  uvmt_cv32_tb.u_debug_assert.a_enter_debug A:a_dt_instr_trigger_hit_*",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac\n\nRISCV-V External Debug Support Version 0.13.2",
        "Requirement Location": "Debug chapter \n\n\n\nChapter 5",
        "Feature": "Trigger module",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "When trigger module is disabled, no trigger should fire even though the PC matches the address in tdata2.",
        "Verification Goal": "Enter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and disable breakpoint in tdata1\nExit debug mode (dret instruction)\nVerify that core does not enter debug mode on breakpoint addr\n",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_trigger\"",
        "Review (Marton)": "",
        "Review (Robin)": "Why is the \"Trigger module\" Feature in red text?",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Enter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and disable breakpoint in tdata1\nExit debug mode (dret instruction)\nVerify that core does not enter debug mode on breakpoint addr\n",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: cg_trigger_match_disabled\nA:   uvmt_cv32_tb.u_debug_assert.a_trigger_match_disabled\n",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "40S User Manual 0.8.0",
        "Requirement Location": "Debug & Trigger",
        "Feature": "Trigger module",
        "Sub Feature": "Number of triggers",
        "Feature Description": "The number of triggers is determined by DBG_NUM_TRIGGERS.\nWhen num triggers is 0, accessing the trigger registers causes illegal instruction exception.\nTriggers never fire.\n\"tselect\" is 0.",
        "Verification Goal": "Have 0 triggers, access any trigger register and check that illegal instruction exception occurs. Check that no triggers ever fire. Check that \"tselect\" is 0.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[40x? Also below.]\""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Have 0 triggers, access any trigger register and check that illegal instruction exception occurs. Check that no triggers ever fire. Check that \"tselect\" is 0.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A:a_dt_0_triggers_tdata1_access, a_dt_0_triggers_no_triggering",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "The number of triggers is determined by DBG_NUM_TRIGGERS.\nDBG_NUM_TRIGGERS can be any value within 0-4.\n\"tselect\" is WARL (0x0 - (DBG_NUM_TRIGGERS-1)).\nAll selectable triggers are functional.\nAll trigger registers are accessible except for \"mcontext\", \"mscontext\", \"hcontext\", and \"scontext\" (those four trap upon access).",
        "Verification Goal": "For all number of triggers, use tselect to exercise each trigger with each supported type. (Also try writing to higher \"tselect\" than supported and check that a supported number is read back.) Make the triggers fire and check that debug mode is entered. Check also that the four context registers trap when accessed.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "There are a lot of things to check in a single point here. Nothing is wrong with this point as I see it, so there is no need to change, but ideally this point should be split up.",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "For all number of triggers, use tselect to exercise each trigger with each supported type. (Also try writing to higher \"tselect\" than supported and check that a supported number is read back.) Make the triggers fire and check that debug mode is entered. Check also that the four context registers trap when accessed.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_access_context, a_dt_tselect_higher_than_dbg_num_triggers, a_dt_instr_trigger_hit_*, a_dt_load_trigger_hit_*, a_dt_store_trigger_hit_*, a_dt_exception_trigger_hit_*, a_dt_enter_dbg_reason. COV: c_trigger_i_has_type_mcontrol, c_trigger_i_has_type_etrigger, c_trigger_i_has_type_mcontrol6, c_trigger_i_has_type_disable",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "User Manual v0.9.0.",
        "Requirement Location": "Control and Status Registers",
        "Feature": "Trigger module",
        "Sub Feature": "tcontrol",
        "Feature Description": "\"tcontrol\" doesn't exist.",
        "Verification Goal": "Check that attempts to access \"tcontrol\" raise an illegal instruction exception, always. (Unless overruled by a higher priority.)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Check that attempts to access \"tcontrol\" raise an illegal instruction exception, always. (Unless overruled by a higher priority.)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_tcontrol_not_implemented",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "\"mcontrol6\" compare values",
        "Feature Description": "\nInstr execute matching uses only one \"compare value\" (the PC itself).\nLoad/Store matching uses compare values depending on the size of the access {A, A+1, etc}.",
        "Verification Goal": "Exercise address match triggers for instr/load/store with different sizes (16/32 for instr, 8/16/32 for loadstore). Check that instr match only happens on the exact address. Check that loadstore addr matching triggers on any byte.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Exercise address match triggers for instr/load/store with different sizes (16/32 for instr, 8/16/32 for loadstore). Check that instr match only happens on the exact address. Check that loadstore addr matching triggers on any byte.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_enter_dbg_reason, a_dt_instr_trigger_hit_*, a_dt_load_trigger_hit_*, a_dt_store_trigger_hit_*",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "User Manual v0.9.0.\n\nDebug 1.0-STABLE fb7025",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "Mcontrol6Hit",
        "Feature Description": "When a trigger fires, it's \"mcontrol6.hit\" field gets set to 1.\n(This is also true when multiple triggers fire at once.)",
        "Verification Goal": "Induce firing of a trigger.\nCheck that the corresponding \"hit\" field gets set.\nDo the same for variations of multiple triggers firing at once.\nCheck that the field is WARL 0x0, 0x1.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Induce firing of a trigger.\nCheck that the corresponding \"hit\" field gets set.\nDo the same for variations of multiple triggers firing at once.\nCheck that the field is WARL 0x0, 0x1.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_m6_hit_bit\na_dt_warl_tdata1_m6",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "Mcontrol6Match",
        "Feature Description": "Supported match conditions in \"mcontrol6.match\" are {0 (eq), 2 (geq), 3 (less)}.",
        "Verification Goal": "Configure triggers using all three match conditions, exercise them within and outside of the conditions, check that debug mode is/isn't entered. Must also cross against the \"match types\" item above.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Configure triggers using all three match conditions, exercise them within and outside of the conditions, check that debug mode is/isn't entered. Must also cross against the \"match types\" item above.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_enter_dbg_reason, a_dt_instr_trigger_hit_*, a_dt_load_trigger_hit_*, a_dt_store_trigger_hit_*",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "Mcontrol6UM",
        "Feature Description": "Triggers can be en/disabled in M-mode, \"mcontrol6.m\", default is 0.\n40S, triggers can be en/disabled in U-mode, \"mcontrol6.u\", default is 0.\n40X, triggers cannot be enabled in U-mode, \"mcontrol6.u\", WARL (0x0).\nThe trigger action is always to enter D-mode, so \"mcontrol6.action\" is always 1.",
        "Verification Goal": "Have triggers configured to be able to match, but enable/disable their corresponding mode bit, check that the trigger is either able to fire or is blocked from firing accordingly. Also check the tied values.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Have triggers configured to be able to match, but enable/disable their corresponding mode bit, check that the trigger is either able to fire or is blocked from firing accordingly. Also check the tied values.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A:a_dt_instr_trigger_hit_*, a_dt_load_trigger_hit_*, a_dt_store_trigger_hit_*, a_dt_exception_trigger_hit_*, a_dt_enter_dbg_reason, a_dt_tie_offs_*",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "Mcontrol6LoadStoreExecute",
        "Feature Description": "The \"load\" and \"store\" bits are supported (so load/store addr matching is supported).\nThe \"execute\" bit is also supported.\nThe only supported match types are \"address match\" for {instr execution, load, store}, all using \"before\" timing.\nData matching is not supported (only addr matching), so \"mcontrol6.select\" is always 0.",
        "Verification Goal": "Configure triggers for load/store/execute and combinations of them, configure tdata2, cause triggers to fire and check that debug mode is entered correctly.  All of these configurations must be crossed, also against match conditions.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "\"tdata3\" and \"tcontrol\" should be removed.",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Configure triggers for load/store/execute and combinations of them, configure tdata2, cause triggers to fire and check that debug mode is entered correctly.  All of these configurations must be crossed, also against match conditions.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_instr_trigger_hit_*, a_dt_load_trigger_hit_*, a_dt_store_trigger_hit_*. ",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "User Manual v0.9.0.",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "trigger csrs",
        "Feature Description": "Some fields in the trigger csrs are hardwired.",
        "Verification Goal": "Check that the tied fields are tied.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "TODO csr access test? ",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Check that the tied fields are tied.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_tie_offs_tselect, a_dt_tie_offs_tdata1_mcontrol, a_dt_tie_offs_tdata1_etrigger, a_dt_tie_offs_tdata1_mcontrol6, a_dt_tie_offs_tdata1_disabled, a_dt_tie_offs_tdata2_etrigger. a_dt_tie_offs_tinfo.",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "\"mcontrol6\" atomics",
        "Feature Description": "40X, \"mcontrol6\" trigger behavior has specific descriptions for \"A\" extension.",
        "Verification Goal": "40X, TODO this section must be filled out when the time comes for planning atomics verification.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "40S User Manual\n\nDebug 1.0.0",
        "Requirement Location": "Control and Status Registers\n\nTrigger Data 1",
        "Feature": "Trigger module",
        "Sub Feature": "\"tdata1.type\"",
        "Feature Description": "The only supported types are \"2 = address match legacy\", \"5 = Exception trigger\", \"6 = Address match\",  and \"15 = Disabled\".",
        "Verification Goal": "Check that these types can be selected, and check that no other types can be selected. (Functionality of these types should be handled by other items in this plan.) Check also that the default is \"15\".",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[type 2]\""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Check that these types can be selected, and check that no other types can be selected. (Functionality of these types should be handled by other items in this plan.) Check also that the default is \"15\".",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_tdata1_types",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[type 2]\""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "\"tdata1.dmode\"",
        "Feature Description": "This bit is WARL (0x1), so only D-mode can write tdata registers. And this bit is still WARL (0x1) regardless of \"type\" (2, 5, 6, 15).",
        "Verification Goal": "Try to write tdata registers outside of debug mode, check that they are not writable. Try changing \"tdata1.dmode\" and check that it is WARL (0x1). Cross the above checks with all supported types.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Try to write tdata registers outside of debug mode, check that they are not writable. Try changing \"tdata1.dmode\" and check that it is WARL (0x1). Cross the above checks with all supported types.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_not_access_tdata1_dbg_mode,  a_dt_not_access_tdata2_dbg_mode, a_dt_dmode",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "40S User Manual\n\nDebug 1.0.0",
        "Requirement Location": "Control and Status Registers\n\nTrigger Info",
        "Feature": "Trigger module",
        "Sub Feature": "\"tinfo\"",
        "Feature Description": "\"tinfo.info\" holds the  supported types {2, 5, 6, 15},\n\"tinfo.version\" holds the \"Sdtrig\" spec version,\nand the register is otherwise WARL (0x0).",
        "Verification Goal": "\nWhen num triggers is more than 0, check that \"tinfo.info\" is \"1\" for the three supported types,\n\"tinfo.version\" is 0x1,\nand that the remaining bits are 0.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[type 2]\""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "\nWhen num triggers is more than 0, check that \"tinfo.info\" is \"1\" for the three supported types,\n\"tinfo.version\" is 0x1,\nand that the remaining bits are 0.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_triggers_tinfo",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "\"[type 2]\""
    },
    {
        "Reference document": "40S User Manual\n\nDebug 1.0.0",
        "Requirement Location": "Control and Status Registers\n\nException Trigger",
        "Feature": "Trigger module",
        "Sub Feature": "\"etrigger\"",
        "Feature Description": "A trigger (\"tdata1\") can be configured as an exception trigger (\"etrigger\"). Where \"tdata2\" configures the exceptions to fire upon.",
        "Verification Goal": "Configure \"tdata1\" and \"tdata2\" to fire on exceptions, try both individual and multiple exceptions in addition to supported and unsupported. Exercise scenarios that would trigger or not trigger according to the configuration and check that debug mode is either entered or not entered accordingly, and that the entry goes correctly (pc, dpc, cause, etc).",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Configure \"tdata1\" and \"tdata2\" to fire on exceptions, try both individual and multiple exceptions in addition to supported and unsupported. Exercise scenarios that would trigger or not trigger according to the configuration and check that debug mode is either entered or not entered accordingly, and that the entry goes correctly (pc, dpc, cause, etc).",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_exception_trigger_hit_*, a_dt_enter_dbg_reason, a_glitch_dt_exception_trigger_hit_*",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "The bits {\"hit\", \"vs\", \"vu\", \"s\"} are not supported (WARL 0).\n\"nmi\" does not exist (mentioned because it briefly did).\n\"m\" is fully supported.\n40S, \"u\" is fully supported.\n40X, \"u\" is not supported (WARL0).\nThe triggers always enter D-mode, so \"etrigger.action\" is WARL 1.",
        "Verification Goal": "Configure an exception trigger, use the privmode bits to disable/enable the trigger, exercise the trigger conditions, check that it fires/not accordingly. Also check the WARL fields.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "\"tdata3\" and \"tcontrol\" should be removed.",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Configure an exception trigger, use the privmode bits to disable/enable the trigger, exercise the trigger conditions, check that it fires/not accordingly. Also check the WARL fields.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_exception_trigger_hit_*, a_dt_enter_dbg_reason, a_dt_warl_tselect, a_dt_warl_tdata1_general, a_dt_warl_tdata1_m2, a_dt_warl_tdata1_etrigger, a_dt_warl_tdata1_m6, a_dt_warl_tdata1_disabled, a_dt_warl_tdata2_etrigger, a_dt_warl_tinfo. ",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "40s User Manual 0.8.0",
        "Requirement Location": "Debug Chapter",
        "Feature": "debug_pc_o",
        "Sub Feature": "",
        "Feature Description": "Signal \"debug_pc_o\" is the PC of the last retired instruction The signal is only valid when \"debug_pc_valid_o\" is equal to 1",
        "Verification Goal": "Verify that the signal can be matched with related rvfi signals",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Assertion Check",
        "Coverage Method": "Assertion Coverage",
        "Link to Coverage": "A:   uvmt_cv32_tb.u_debug_assert.a_debug_pc_o\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_pc_o_inv",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "40S User Manual 0.8.0",
        "Requirement Location": "Debug chapter",
        "Feature": "Debug exception addr",
        "Sub Feature": "",
        "Feature Description": "If an exception occurs during debug mode, the PC should be set to the dm_exception_addr_i input without changing the status registers",
        "Verification Goal": "Bring core into debug mode, generate all exception types and observe that the PC jumps to the address given by dm_exception_addr_i. Observe no change in status registers\nAccording to specification, the core supports several types of exceptions: {instr access fault, illegal instruction, ... etc}",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: illegal_csr_in_dmode\ntc: ecall_in_dmode\ntc: mret_in_dmode\ntc: single_step",
        "Review (Marton)": "Point mentions the exceptions supported by the e40p, need to match 40s/x capabilities and update text",
        "Review (Robin)": "\"0.8.0\"",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug exception addr",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Bring core into debug mode, generate all exception types and observe that the PC jumps to the address given by dm_exception_addr_i. Observe no change in status registers\nAccording to specification, the core supports several types of exceptions: {instr access fault, illegal instruction, ... etc}",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_exception\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_ecall\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_mode_exception",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "40S User Manual 0.8.0",
        "Requirement Location": "Debug chapter",
        "Feature": "Core debug registers",
        "Sub Feature": "Illegal access",
        "Feature Description": "Accessing the core debug registers - DCSR, DPC and DSCRATCH0/1 while NOT in debug mode causes an illegal instruction",
        "Verification Goal": "Access all debug registers in M-mode and observe that illegal instruction exception is triggered.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Non-Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: debug_csr_rw",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Core debug registers",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Access all debug registers in M-mode and observe that illegal instruction exception is triggered.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_regs_m_mode\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_regs_mmode",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "Debug Control and Status",
        "Feature": "\"dcsr\" writability",
        "Sub Feature": "",
        "Feature Description": "All fields of \"dcsr\" (except some) are only writable by the external debugger. Exceptions are {\"v\", \"prv\", \"cause\", \"nmip\"}.",
        "Verification Goal": "Keep track of whether an external debug request has happened, check that if there is a change in \"dcsr\" (except some) then there must have been an external debug request.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "40S User Manual 0.8.0",
        "Requirement Location": "Debug chapter",
        "Feature": "Trigger module registers",
        "Sub Feature": "Access from M-mode",
        "Feature Description": "Accessing the tdata1/2 registers are readable from M-mode, but not writeable. (And is not accessible at all from U-mode.)",
        "Verification Goal": "Access all tdata registers in M-mode and observe writes have no effects and reads should reflect register content.\n\nAccess registers from D-mode and observe full R/W access.\n\nAccess from U-mode and observe no access at all.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\".",
        "Review (Marton)": "Should we also check r/w in U-mode?",
        "Review (Robin)": "\"tdata3\" should be removed.",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Access all tdata registers in M-mode and observe writes have no effects and reads should reflect register content.\n\nAccess registers from D-mode and observe full R/W access.\n\nAccess from U-mode and observe no access at all.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_trigger_regs.  A: a_dt_no_write_access_to_tdata_in_mmode,\na_dt_read_access_to_tdata1_in_mmode,\na_dt_read_access_to_tdata2_in_mmode,\na_dt_write_access_to_tdata1_in_dmode,\na_dt_write_access_to_tdata2_in_dmode,\na_dt_read_access_to_tdata1_in_dmode,\na_dt_read_access_to_tdata2_in_dmode,\na_dt_no_access_to_tdata_in_umode.\nCOV: c_dt_write_tdata1_in_mmode,\nc_dt_write_tdata2_in_mmode.\n\n",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "Trigger Registers",
        "Feature": "Trigger module registers",
        "Sub Feature": "\"tdata1\", writing zero",
        "Feature Description": "\"it is guaranteed that writing 0 to tdata1 disables the trigger, and leaves it in a state where tdata2 and tdata3 can be written with any value that makes sense for any trigger type supported by this trigger.\"\n\nMore generally, \"When a selected trigger is disabled [type 15], tdata2 and tdata3 can be written with any value supported by any of the types this trigger supports\".",
        "Verification Goal": "Write 0 to \"tdata1\", ensure that its state becomes disabled (type 15). Write values to \"tdata2\" (addresses and/or exception causes) and exercise would-have-been triggers and check that the trigger does not fire.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Write 0 to \"tdata1\", ensure that its state becomes disabled (type 15). Write values to \"tdata2\" (addresses and/or exception causes) and exercise would-have-been triggers and check that the trigger does not fire.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_write_0_to_tdata1,\na_dt_enter_dbg_reason",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "Debug 1.0.0\nUserManual v0.9.0.",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "tdata2",
        "Feature Description": "\"tdata2\" should always be RW (any) for type 2/6/15.",
        "Verification Goal": "Change the type to 2/6/15 and write any data to \"tdata2\", read it back and check that it always gets set.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "\"tdata3\" should be removed.",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Change the type to 2/6/15 and write any data to \"tdata2\", read it back and check that it always gets set.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_write_tdata2_random_in_dmode_type_2_6_15. COV: c_dt_w_csrrw_tdata2_m2_m6_disabled,\nc_dt_w_csrrs_tdata2_m2_m6_disabled,\nc_dt_w_csrrc_tdata2_m2_m6_disabled,\nc_dt_w_csrrwi_tdata2_m2_m6_disabled,\nc_dt_w_csrrsi_tdata2_m2_m6_disabled,\nc_dt_w_csrrci_tdata2_m2_m6_disabled",
        "Review (Marton)": "?",
        "Review (Robin)": "Type 2",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "User Manual v0.9.0.",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "tdata3",
        "Feature Description": "\"tdata3\" doesn't exist.",
        "Verification Goal": "Check that attempts to access \"tdata3\" raise an illegal instruction exception, always. (Unless overruled by a higher priority.)\nVerify that tdata3 is illegal for all tdata2 types.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Check that attempts to access \"tdata3\" raise an illegal instruction exception, always. (Unless overruled by a higher priority.)\nVerify that tdata3 is illegal for all tdata2 types.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_tdata3_not_implemented. COV: c_dt_access_tdata3_m2, c_dt_access_tdata3_etrigger, c_dt_access_tdata3_m6, c_dt_access_tdata3_disabled.",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "Other tdata registers",
        "Feature Description": "Writing one \"tdata*\" register must not modify other \"tdata*\" registers, and must not modify other triggers than the currently selected.",
        "Verification Goal": "Read the state of all triggers, write to tdata1/2 (using all types in tdata1), read back the state of all triggers and check that nothing got changes except the one \"tdata*\" register that was written.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "\"tdata3\" should be removed.",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger module registers",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Read the state of all triggers, write to tdata1/2 (using all types in tdata1), read back the state of all triggers and check that nothing got changes except the one \"tdata*\" register that was written.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: a_dt_write_only_tdata1,\na_dt_write_only_tdata2.",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt2",
        "Feature": "Program Buffer",
        "Sub Feature": "Interrupts",
        "Feature Description": "While in debug mode and executing from the program buffer, all interrupts are masked.",
        "Verification Goal": "Enable interrupts (setting mstatus.mie field and mie register).\nBring core into debug mode and start executing from program buffer.\nGenerate interrupts while in debug mode and ensure they are masked.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Enable interrupts (setting mstatus.mie field and mie register).\nBring core into debug mode and start executing from program buffer.\nGenerate interrupts while in debug mode and ensure they are masked.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_irq_in_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_irq_in_debug",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt3",
        "Feature": "Program Buffer",
        "Sub Feature": "Exceptions",
        "Feature Description": "While in debug mode and executing from the program buffer, exceptions don\u2019t update any registers but they DO end execution of PB (TBD: goes back to M-mode or restarts in debug(?)) [PZ] this is redundnant with dm_exception_addr_i (on line 10 & 11)",
        "Verification Goal": "Bring core into debug mode and start executing from program buffer. Make sure PB includes code that will hit an exception. Make sure core doesn\u2019t update any registers, and jumps out of debug mode into M-mode",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Bring core into debug mode and start executing from program buffer. Make sure PB includes code that will hit an exception. Make sure core doesn\u2019t update any registers, and jumps out of debug mode into M-mode",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt4",
        "Feature": "Program Buffer",
        "Sub Feature": "Triggers",
        "Feature Description": "While in debug mode and executing from the program buffer, no action is taken on any trigger match.",
        "Verification Goal": "Bring core into debug and enable a trigger on the PC (pointing to the debug program buffer). Continue execution in debug, and observe that no action is taken when the trigger matches.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\". ",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Bring core into debug and enable a trigger on the PC (pointing to the debug program buffer). Continue execution in debug, and observe that no action is taken when the trigger matches.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_trigger_match_disabled (d_match_with_en) A:a_dt_no_actions_on_trigger_matches_in_debug_dcsr\na_dt_no_actions_on_trigger_matches_in_debug_dpc",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "dcsr",
        "Feature": "Counters",
        "Sub Feature": "",
        "Feature Description": "Spec:Counters may be stopped, depending on stopcount in dscr",
        "Verification Goal": "\"dcsr.stopcount\" is WARL and we must test the counter bevaior for both values of stopcount.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: test_stopcnt_bits",
        "Review (Marton)": "?",
        "Review (Robin)": "Is wrong, need update.",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Counters",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "\"dcsr.stopcount\" is WARL and we must test the counter bevaior for both values of stopcount.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_counters_enabled\nA:   uvmt_cv32_tb.u_debug_assert.a_minstret_count\nA:   uvmt_cv32_tb.u_debug_assert.a_mcycle_count",
        "Review (Marton)": "?",
        "Review (Robin)": "Any other \"40p\" outdateds here? Marked them all.",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt6",
        "Feature": "Program Buffer",
        "Sub Feature": "Timers",
        "Feature Description": "Timers may be stopped, depending on stoptime in dcsr",
        "Verification Goal": "(See \"Counters\" above.)",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "Fix \"40p\"",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt7",
        "Feature": "Program Buffer",
        "Sub Feature": "WFI instruction",
        "Feature Description": "In debug, the WFI instruction acts as a NOP instruction",
        "Verification Goal": "Bring core into debug mode. Ensure that an WFI instruction will be executed from the program buffer. Ensure that the WFI will act as a nop, not waiting for an interrupt to occur.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Bring core into debug mode. Ensure that an WFI instruction will be executed from the program buffer. Ensure that the WFI will act as a nop, not waiting for an interrupt to occur.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_wfi_in_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_wfi_in_debug",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt8",
        "Feature": "Program Buffer",
        "Sub Feature": "Priv. lvl changes",
        "Feature Description": "An ebreak instruction during debug shall result in relaunching the debugger entry code by setting the PC to the halt_addr_i and will not change any CSR in doing this.",
        "Verification Goal": "Bring hart into debug mode and start executing from the Program Buffer. Make sure the PB code includes an ebreak instruction. When the ebreak is executed, the hart must halt and not update dpc or dcsr. Ensure relaunch of debugger entry",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: request_ebreak_3x",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Bring hart into debug mode and start executing from the Program Buffer. Make sure the PB code includes an ebreak instruction. When the ebreak is executed, the hart must halt and not update dpc or dcsr. Ensure relaunch of debugger entry",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_with_ebreakm (.ebreak_in_debug)\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_with_ebreakm (.ebreak_in_debug)\nA:   uvmt_cv32_tb.u_debug_assert.a_ebreak_during_debug_mode",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt9",
        "Feature": "Program Buffer",
        "Sub Feature": "Fence instructions",
        "Feature Description": "Completing program buffer execution is considered output for the purpose of the fence instruction.",
        "Verification Goal": "TBD - need to understand the fence instruction in cv32e40s. Is \"completing program buffer execution\" the same as executing dret? [PZ] waiting for more clarity from RISCV Foundation debug task group (see https://lists.riscv.org/g/tech-debug/topic/clarification_request/75725318?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,75725318 )\n\nNothing to do. That sentence was retracted here https://github.com/riscv/riscv-debug-spec/pull/601/files . Now it seems they just recommend debug software to do a fence when completing abstract commands.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "What are we doing here?",
        "Review (Robin)": "Added N/A disclaimer. Striking it.",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt10",
        "Feature": "Program Buffer",
        "Sub Feature": "Ctrl. Transfer instr.",
        "Feature Description": "All control transfer instructions may act as illegal instructions if destination is within program buffer. If one does, all must.",
        "Verification Goal": "N/A for CV32E40s : need Arjan/Davide to sign-off on this. [PZ] This is not supported and it is mentioned in the CV32E40s debug spec. No verification needed to prove nor dis-prove this behavior",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "Fix \"40p\"",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt11",
        "Feature": "Program Buffer",
        "Sub Feature": "Ctrl. Transfer instr.",
        "Feature Description": "All control transfer instructions may as illegal instructions if destination is outside the program buffer. If one does, all must.",
        "Verification Goal": "N/A for CV32E40s : need Arjan/Davide to sign-off on this. [PZ] This is not supported and it is mentioned in the CV32E40s debug spec. No verification needed to prove nor dis-prove this behavior",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "Fix \"40p\"",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt12",
        "Feature": "Program Buffer",
        "Sub Feature": "Instr. Dependent of PC",
        "Feature Description": "Instructions that depend on the PC may act as illegal instructions",
        "Verification Goal": "N/A for CV32E40s : need Arjan/Davide to sign-off on this. [PZ] This is not supported and it is mentioned in the CV32E40s debug spec. No verification needed to prove nor dis-prove this behavior",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "Fix \"40p\"",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt13",
        "Feature": "Program Buffer",
        "Sub Feature": "Effective XLEN",
        "Feature Description": "Effective XLEN = DXLEN",
        "Verification Goal": "CV32E40s XLEN=1 (32 bits).  DXLEN is defined as the widest supported XLEN. For now, this will be 1 (32 bits). Check XLEN M- and D-mode\nMike: what exactly would a testcase actually do to check this?\n\u00d8K: As discussed in the meeting 02.July, this is probably a SW/DM problem. Leaving it here for reference.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "CV32E40s XLEN=1 (32 bits).  DXLEN is defined as the widest supported XLEN. For now, this will be 1 (32 bits). Check XLEN M- and D-mode\nMike: what exactly would a testcase actually do to check this?\n\u00d8K: As discussed in the meeting 02.July, this is probably a SW/DM problem. Leaving it here for reference.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "Fix \"40p\"",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.2 Load-Reserved/Store-Conditional",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "N/A for CV32E40s (requires A-extention) : need Arjan/Davide to sign-off on this. [PZ] This is not a test but a warning or assumption that debug entry should not occur between a lr and sc instruction pair. Moreover, CV32E40s does not support A-extension",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "Fix \"40p\"",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.3 Wait for interrupt",
        "Feature": "Debug mode",
        "Sub Feature": "WFI instruction",
        "Feature Description": "If debug_req_i is asserted while waiting for interrupt (core_sleep_o = 1), WFI instruction must complete (core_sleep_o -> 0) and hart enters debug mode.",
        "Verification Goal": "Insert WFI instruction into arbitrary code. While the hart is waiting for an interrupt, request debug mode. The hart must stop waiting for interrupt and enter debug mode. WFI at trigger will be converted to a NOP and should be a dedicated test. See #pz_ref2 in this sheet below",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: wfi_before_dmode",
        "Review (Marton)": "Update reference document, applies to several following points",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Insert WFI instruction into arbitrary code. While the hart is waiting for an interrupt, request debug mode. The hart must stop waiting for interrupt and enter debug mode. WFI at trigger will be converted to a NOP and should be a dedicated test. See #pz_ref2 in this sheet below",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_wfi_debug_req\nA:   uvmt_cv32_tb.u_debug_assert.a_sleep_debug_req_wu\nA:   uvmt_cv32_tb.u_debug_assert.a_sleep_debug_req",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "By setting step in dcsr[2] before resuming execution, a debugger can cause the hart to execute a single instructin before re-entering debug mode.",
        "Verification Goal": "Bring the hart into debug mode. Set the step bit in dcsr[2] and then resume execution. Observe that the hart runs a single instruction and the goes back to debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: single_step",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Bring the hart into debug mode. Set the step bit in dcsr[2] and then resume execution. Observe that the hart runs a single instruction and the goes back to debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step)\nA:   uvmt_cv32_tb.u_debug_assert.a_single_step\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the instruction being fetched or executed in a single step casues an exception, debug mode is entered immediately after the PC is changed to the exception handler and registers tval and cause are updated.\n\nNote: CV32E40S does not support tval (this might be supported in future cores)",
        "Verification Goal": "Perform a single step. Make sure the instruction executed in the step will cause an exception. PC must jump to the exception handler address and update tval and cause and then immediately enter debug mode.\n\nCheck tval==0",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: single_step",
        "Review (Marton)": "Update to reflect that we are now checking \"future cores\"",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Perform a single step. Make sure the instruction executed in the step will cause an exception. PC must jump to the exception handler address and update tval and cause and then immediately enter debug mode.\n\nCheck tval==0",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_illegal)\nA:   uvmt_cv32_tb.u_debug_assert.a_single_step_exception",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the instruction being fetched or executed in a single step causes a trigger, debug mode is entered immediately after the trigger fired. Cause is set to 2 instead of 4",
        "Verification Goal": "Set up the trigger module to match on instruction address. Set up single stepping such that the match address will be executed in a step. The trigger module must fire during the step, and debug mode entered with cause = 2 to identify that the trigger was fired. (#1)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: single_step",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Set up the trigger module to match on instruction address. Set up single stepping such that the match address will be executed in a step. The trigger module must fire during the step, and debug mode entered with cause = 2 to identify that the trigger was fired. (#1)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_trigger_match)\nA:    uvmt_cv32_tb.u_debug_assert.a_single_step_trigger\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the intruction executed in the single step results in a PC that will cause an exception, the exception will not execute until the next time the hart resumes.",
        "Verification Goal": "Make sure that an instruction in the instruction memory will generate a PC that causes an exception. Set up single stepping and make sure to step through this specific instruction. Hart must go back to debug mode after stepping, and the exception must not start executing until the next time the hart resumes (either single step or exit debug mode)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Make sure that an instruction in the instruction memory will generate a PC that causes an exception. Set up single stepping and make sure to step through this specific instruction. Hart must go back to debug mode after stepping, and the exception must not start executing until the next time the hart resumes (either single step or exit debug mode)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the intruction executed in the single step results in a PC that will cause a trigger event, the trigger event will not take place until the instruction is executed.",
        "Verification Goal": "This can be verified in the same steps as marked with (#1).\nMike: this may be difficult to accurately predict in the ISS.  This is good input for the Imperas team.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: single_step",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "This can be verified in the same steps as marked with (#1).\nMike: this may be difficult to accurately predict in the ISS.  This is good input for the Imperas team.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_next_pc_will_match)\nA: uvmt_cv32_tb.u_debug_assert.a_single_step_trigger\nA: uvmt_cv32_tb.u_debug_assert.a_enter_debug",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the single step instruction is WFI, it must be treated as a nop instead of stalling and waiting for interrupt. [PZ] #pz_ref2",
        "Verification Goal": "Perform a single step where the instruction to be executed is a WFI instruction. The hart must not wait for interrupt, but treat the instruction as as NOP and re-enter debug after finishing the step.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: single_step",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Perform a single step where the instruction to be executed is a WFI instruction. The hart must not wait for interrupt, but treat the instruction as as NOP and re-enter debug after finishing the step.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_wfi)\nA:   uvmt_cv32_tb.u_debug_assert.a_single_step_wfi",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.5 Reset",
        "Feature": "Debug mode",
        "Sub Feature": "Reset",
        "Feature Description": "When the hart comes out of reset, it must immediately enter debug mode without executing any instructions if the halt signal or debug_req_i is asserted.",
        "Verification Goal": "Assert the core reset AND the debug_req_i signal. The hart must not execute any instructions, but immediately enter debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_reset\"",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Assert the core reset AND the debug_req_i signal. The hart must not execute any instructions, but immediately enter debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_at_reset\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_at_reset",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.6 dret instruction",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "Executing dret while NOT in debug mode will cause an illegal instruction exception.",
        "Verification Goal": "Insert dret into arbitrary code running in m-mode, observe that the illegal insctruction exception is thrown.\nCan be tested in the same test as for debug entry",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: dret_in_mmode",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Insert dret into arbitrary code running in m-mode, observe that the illegal insctruction exception is thrown.\nCan be tested in the same test as for debug entry",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_mmode_dret\nA:  uvmt_cv32_tb.u_debug_assert.a_mumode_dret",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.6 dret instruction",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "Executing dret while in debug mode will restore PC to the value in dpc and exit debug mode.",
        "Verification Goal": "Bring hart into debug mode. Execute a dret instruction and observe that the hart resumes executing from the correct address as given by dpc. \nCan be tested in the same test as for debug entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: all testcases that enter and exit debug mode (most)",
        "Review (Marton)": "remove note, this is covered or 40s (U-Mode) in the next point",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Bring hart into debug mode. Execute a dret instruction and observe that the hart resumes executing from the correct address as given by dpc. \nCan be tested in the same test as for debug entry.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_mmode_dret\nA:   uvmt_cv32_tb.u_debug_assert.a_dmode_dret",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "Execution Based",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "40S, \"When dret is executed, [\u2026] normal execution resumes at the privilege set by prv\"",
        "Verification Goal": "Be in debug mode, note the value in \"dcsr.prv\", exit debug mode with a \"dret\", check that the mode being executed in is the one indicated by \"dcsr.prv\". (Note overlap with user mode vplan.)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: mprv_dret_to_umode",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Be in debug mode, note the value in \"dcsr.prv\", exit debug mode with a \"dret\", check that the mode being executed in is the one indicated by \"dcsr.prv\". (Note overlap with user mode vplan.)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "Resume",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "40S, \"If the new privilege mode is less privileged than M-mode, MPRV in mstatus is cleared.\"",
        "Verification Goal": "Be in debug mode, set \"dcsr.prv\" to U-mode, let \"mstatus.MPRV\" be set and clear (different runs), exit debug mode with a \"dret\", check that \"mstatus.MPRV\" ends up cleared. (Note overlap with user mode vplan.)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: mprv_dret_to_umode",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Be in debug mode, set \"dcsr.prv\" to U-mode, let \"mstatus.MPRV\" be set and clear (different runs), exit debug mode with a \"dret\", check that \"mstatus.MPRV\" ends up cleared. (Note overlap with user mode vplan.)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "Debug Control and Status",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "\"Upon entry into Debug Mode, v and prv are updated with the privilege level the hart was previously in\"",
        "Verification Goal": "40S, enter debug mode from different modes, check that \"dcsr.prv\" represents the previous mode. (Note overlap with user mode vplan.)\n\n40X, check that \"dcsr.prv\" is always M-mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test2\"\ntc: mprv_dret_to_umode",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Debug mode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "40S, enter debug mode from different modes, check that \"dcsr.prv\" represents the previous mode. (Note overlap with user mode vplan.)\n\n40X, check that \"dcsr.prv\" is always M-mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Semihosting",
        "Sub Feature": "",
        "Feature Description": "To enable semihosting, a special instruction sequence is needed as there is only a single EBREAK instruction available.\n\nslli x0, x0, 0x1f # Entry NOP\nebreak # Break to debugger\nsrai x0, x0, 7 # NOP encoding the semihosting call number 7\n\n[PZ] This is a software convention and need not be tested in verification. As long as the above instructions work in general, then no need for dedicated semihosting testing.",
        "Verification Goal": "If all points above passes, there should be nothing to verify here. Semihosting will be handled from SW.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "N/A",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger",
        "Sub Feature": "Exception handling",
        "Feature Description": "If the trigger matches on an illegal instruction, PC must be set to the exception handler prior to entering debug mode.",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. When the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "With \"before timing\" the core will not attempt to execute instruction at trigger address",
        "Review (Marton)": "",
        "Review (Robin)": "\"link to coverage\": Is this merely claimed? Can we either test it or change the relevant vplan items?",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. When the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "With \"before timing\" the core will not attempt to execute instruction at trigger address\n\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause\nA:   uvmt_cv32_tb.u_debug_assert.a_dpc_dbg_trigger",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger, single step",
        "Sub Feature": "Exception handling",
        "Feature Description": "If the trigger matches on an illegal instruction, PC must be set to the exception handler prior to entering debug mode.",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. \nSet up single stepping such that the match address will be executed in the next step.\nWhen the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "With \"before timing\" the core will not attempt to execute instruction at trigger address",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Trigger, single step",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. \nSet up single stepping such that the match address will be executed in the next step.\nWhen the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "With \"before timing\" the core will not attempt to execute instruction at trigger address\n\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause\nA:   uvmt_cv32_tb.u_debug_assert.a_dpc_dbg_trigger",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "40S User Manual 0.8.0\n\nOBI-v1.4",
        "Requirement Location": "Core Integration\n\ndbg",
        "Feature": "OBI",
        "Sub Feature": "",
        "Feature Description": "OBI bus accesses shall indicate whether the core is in D-mode or not, signaled via \"instr_dbg_o\" and \"data_dbg_o\".",
        "Verification Goal": "Be in debug mode and be out of debug mode, execute regular instructions and execute loads/stores, check that the corresponding OBI buses have \"dbg\" set correspondingly.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "OBI",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Be in debug mode and be out of debug mode, execute regular instructions and execute loads/stores, check that the corresponding OBI buses have \"dbg\" set correspondingly.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A:   uvmt_cv32_tb.u_debug_assert.a_obi_dbg_instr\nA:   uvmt_cv32_tb.u_debug_assert.a_obi_dbg_instr_inv\nA:   uvmt_cv32_tb.u_debug_assert.a_obi_dbg_data\nA:   uvmt_cv32_tb.u_debug_assert.a_obi_dbg_data_inv",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "40S User Manual 0.8.0\n\nDebug 1.0.0",
        "Requirement Location": "Control and Status Registers\n\nDebug Control and Status",
        "Feature": "NMI",
        "Sub Feature": "",
        "Feature Description": "The \"dcsr.nmip\" bit is supported.\nWhen a non-maskable interrupt is pending, then this bit must be high.",
        "Verification Goal": "Cause an NMI to occur, read \"dcsr.nmip\", check that it is high as expected. Have no NMI pending, read \"dsr.nmip\", check that it is low.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "NMI",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Cause an NMI to occur, read \"dcsr.nmip\", check that it is high as expected. Have no NMI pending, read \"dsr.nmip\", check that it is low.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "40X/S user manual\n\nDebug 1.0.0\n\nPrivspec 1.12",
        "Requirement Location": "Control and Status Registers\n\nDebug Control and Status\n\nMachine Status Registers",
        "Feature": "MPRV",
        "Sub Feature": "",
        "Feature Description": "\"dcsr.mprven\" is WARL 1.\nSince \"mprven\" is 1, then \"mstatus.MPRV\" always takes effect in D-mode.",
        "Verification Goal": "Read \"dcsr.mprven\", check that it is always 1.\n\n40S, be in debug mode, have \"mstatus.MPRV\" disabled, check that all instructions are treated as M-mode. Be in debug mode, have \"mstatus.MPRV\" enabled, have \"mstatus.MPP\" set to M/U-mode (different runs), check that instructions take effect with the modified privilege mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "MPRV",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Read \"dcsr.mprven\", check that it is always 1.\n\n40S, be in debug mode, have \"mstatus.MPRV\" disabled, check that all instructions are treated as M-mode. Be in debug mode, have \"mstatus.MPRV\" enabled, have \"mstatus.MPP\" set to M/U-mode (different runs), check that instructions take effect with the modified privilege mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "Silabs Internal",
        "Requirement Location": "",
        "Feature": "Instruction boundaries",
        "Sub Feature": "Haltreq and stepping",
        "Feature Description": "External debug requests and single stepping can only cause debug entry on \"instruction boundaries\", so a multi-step instruction cannot be interrupted by this.",
        "Verification Goal": "While single stepping, execute misaligned loads/stores, push/pops, and table jumps, cause an external debug request while the instruction has started its sub operations, check that the external debug request does not interrupt the instructions.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Instruction boundaries",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "While single stepping, execute misaligned loads/stores, push/pops, and table jumps, cause an external debug request while the instruction has started its sub operations, check that the external debug request does not interrupt the instructions.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "Debug 1.0.0",
        "Requirement Location": "",
        "Feature": "Instruction boundaries",
        "Sub Feature": "Synchronous entry",
        "Feature Description": "Trigger matching can cause synchronous debug entry, and can interrupt \"within\" and instruction.",
        "Verification Goal": "Set up triggers to match the following scenario, execute misaligned loads/stores, push/pops, and table jumps, have a trigger fire while the instruction has started its sub operations, check that the instruction gets interrupted \"midway\" and that debug mode is entered correctly.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Instruction boundaries",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Set up triggers to match the following scenario, execute misaligned loads/stores, push/pops, and table jumps, have a trigger fire while the instruction has started its sub operations, check that the instruction gets interrupted \"midway\" and that debug mode is entered correctly.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "Single step",
        "Sub Feature": "Interrupts",
        "Feature Description": "While single stepping, interrupts (maskable and non-maskable) may be enabled or disabled using the dcsr.stepie bit. ",
        "Verification Goal": "Set up single stepping. Ensure interrupt is asserted while performing a step. Ensure that the interrupt is taken when dcsr.stepie = 1, and not taken when dcsr.stepie = 0.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Single step",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Set up single stepping. Ensure interrupt is asserted while performing a step. Ensure that the interrupt is taken when dcsr.stepie = 1, and not taken when dcsr.stepie = 0.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (mmode_step_stepie)\nA:   uvmt_cv32_tb.u_debug_assert.a_stepie_irq_dis",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Single step",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Set up single stepping. Ensure NMI is asserted while performing a step. Ensure that the NMI is taken when dcsr.stepie = 1, and not taken when dcsr.stepie = 0.\n",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Single step",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Set up single stepping. Ensure NMI is asserted while performing a step. Ensure that the NMI is taken when dcsr.stepie = 1, and not taken when dcsr.stepie = 0.\n",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvmt_cv32_tb.u_debug_assert.cov_step_stepie_nmi\nA:   uvmt_cv32_tb.u_debug_assert.a_stepie_irq_dis",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Interrupts",
        "Sub Feature": "Simultaneous Interrupt",
        "Feature Description": "",
        "Verification Goal": "Have debug_req_i and interrupt asserted on same clock cycle. Ensure debugger entered with PC reflecting normal PC thread (not the interrupt exception address)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Interrupts",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Have debug_req_i and interrupt asserted on same clock cycle. Ensure debugger entered with PC reflecting normal PC thread (not the interrupt exception address)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_irq_dreq\n\n\"NOTE: not tested specifically, but is covered in formal verification of:\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause\"\n\n\n",
        "Review (Marton)": "What feature is this? Several points in this region lack context, or a merging of left hand cells",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Interrupts",
        "Sub Feature": "Simultaneous NMI",
        "Feature Description": "",
        "Verification Goal": "Have debug_req_i and NMI asserted on same clock cycle. Ensure debugger entered with PC reflecting normal PC thread (not the NMI exception address)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Interrupts",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Have debug_req_i and NMI asserted on same clock cycle. Ensure debugger entered with PC reflecting normal PC thread (not the NMI exception address)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "NOTE: not tested specifically, but is covered in formal verification of:\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "RISCV compliance",
        "Sub Feature": "",
        "Feature Description": "All RISCV code should run in debug mode as well as M mode",
        "Verification Goal": "[PZ] Run RISCV compliance tests all in debug mode",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Waived",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "Corner Cases",
        "Feature Description": "",
        "Verification Goal": "[PZ] assert debug_req and interrupt at the same time as trigger is matching an address (with trigger enabled) and the instruction being 1) illegal instruction 2) exception call (e.g. ebreak with ebreakm==0) 3) branch 4) multicycle instruction (e.g. mulh)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_trigger\"",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "[PZ] assert debug_req and interrupt at the same time as trigger is matching an address (with trigger enabled) and the instruction being 1) illegal instruction 2) exception call (e.g. ebreak with ebreakm==0) 3) branch 4) multicycle instruction (e.g. mulh)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_irq_dreq\n        (.irq_dreq_trig_ill/cebreak/ebreak/branch/multicycle)\n",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "[PZ] Add coverage to ensure debug_req asserted on every FSM state",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_ext\n",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "[PZ] Have trigger address match an instruction that has an illegal instruction (both in normal and single step mode). Ensure debug is enterred with cause set to trigger and PC is set to exception handler prior to debug entry",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "Not possible with \"before timing\", core will not execute instruction at match address before entering debug mode.",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "If a debug_req_i is asserted when an illegal instructions is being executed, the address of the trap handler must be stored to dpc instead of the address of the illegal instruction",
        "Verification Goal": "Assert debug_req_i at the same time as an illegal instruction is being executed, observe that dpc is updated with the address of the trap handler instead of the address of the illegal instruction",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_known_miscompares",
        "Review (Marton)": "Lacks verification goal",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Assert debug_req_i at the same time as an illegal instruction is being executed, observe that dpc is updated with the address of the trap handler instead of the address of the illegal instruction",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: uvmt_cv32_tb.u_debug_assert.a_illegal_insn_debug_req",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "Several causes exist for entering debug, the priority is specified in a table in the \"dcsr\" section of the debug spec.\n\nNote: This changed going to v1.0.0",
        "Verification Goal": "Ensure combinations of reasons exist simultaneously, and observer that the correct cause is stored to dcsr.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Partly covered in DTC \"debug_test\" and \"debug_test_trigger\", the rest will be covered by corev_rand_debug_ebreak and corev_rand_debug_single_step",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure combinations of reasons exist simultaneously, and observer that the correct cause is stored to dcsr.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.debug_causes\n        (.trig_vs_ebreak, trig_vs_cebreak, trig_vs_dbg_req, trig_vs_step\n          ebreak_vs_req, cebreak_vs_req, ebreak_vs_step, cebreak_vs_step, dbg_req_vs_step)",
        "Review (Marton)": "?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "3-way Corners",
        "Feature Description": "* Haltreq, then single-step ebreak\n* Single-step ebreak, then haltreq\n* Single-step ebreak with trigger\n* Single-step ebreak, then trigger on next instr\n* Haltreq, then ebreak with trigger\n* Haltreq, then ebreak, then trigger on next instr\n* Haltreq during ebreak with trigger\n* Haltreq during ebreak, then tirgger on next instr\n(More 3-way corners could be possible, see \"Generated Corners\" below.)",
        "Verification Goal": "Stimulate occurances of all cases, model the outcome (wrt dpc, cause priority, etc), check expectations.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Stimulate occurances of all cases, model the outcome (wrt dpc, cause priority, etc), check expectations.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "NOTE: not tested specifically, but is covered in formal verification of:\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "4-way Corners",
        "Feature Description": "* Haltreq, then single-step ebreak with trigger\n* Haltreq, then single-step ebreak, then trigger on next instr\n* Single-step ebreak with trigger, then haltreq\n* Single-step ebreak, then haltreq and trigger on next instr\n(More 4-way corners could be possible, see \"Generated Corners\" below.)",
        "Verification Goal": "Stimulate occurances of all cases, model the outcome (wrt dpc, cause priority, etc), check expectations.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Stimulate occurances of all cases, model the outcome (wrt dpc, cause priority, etc), check expectations.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "NOTE: not tested specifically, but is covered in formal verification of:\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "Generated Corners",
        "Feature Description": "There are many corners",
        "Verification Goal": "Write a covergroup with all events that can cause debug entry {haltreq, step, etc\u2026} and include timing aspects of first/then (\"e.g. haltreq right after step\", etc\u2026). Then, create a cross of all of these, as that should in principle generate all possible corners if written comprehensively. Finally, review if all of these corners are covered by the assertion set.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "NOTE: not tested specifically, but is covered in formal verification of:\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_dcsr_cause",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Corner Cases",
        "Sub Feature": "Dret",
        "Feature Description": "https://github.com/openhwgroup/core-v-verif/issues/1476",
        "Verification Goal": "Execute \"dret\" in M-mode, followed by a haltreq (as early as possible), so D-mode is entered before the exception handler. Ensure the rest of debug modelling has predictions on all csr and rvfi signals needed for checking this outcome.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: uvmt_cv32_tb.u_debug_assert.a_mumode_dret",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. The cv32e40p would not miss this request, but on the 40s haltreq is no longer sticky and so it should not cause debug entry.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core does not enter debug mode but instead starts executing instructions.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "Review (Marton)": "Deprecated as debug_req is now non-sticky",
        "Review (Robin)": "Fix \"40p\"",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "RISC-V Debug Support Version 1.0.0-STABLE 86e748abed738f8878707dc31fe2713f41868f2c",
        "Requirement Location": "A.2 Execution Based",
        "Feature": "Program Buffer",
        "Sub Feature": "PMP",
        "Feature Description": "\"the PMP must not disallow fetches, loads, or stores in the address range associated with the Debug Module when the hart is in Debug Mode, regardless of how the PMP is configured\"",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "",
        "Review (Marton)": "Any verdict on this now?",
        "Review (Robin)": "?",
        "Review (Henrik)": "?"
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    },
    {
        "Reference document": "",
        "Requirement Location": "---- END ----",
        "Feature": "Program Buffer",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Attempt all kinds of accesses within the region and observe that it is never disallowed , and also attempt all kinds of accesses outside the region and observe both success and failure based on PMP settings.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "Link to Coverage": "",
        "Review (Marton)": "",
        "Review (Robin)": "",
        "Review (Henrik)": ""
    }
]