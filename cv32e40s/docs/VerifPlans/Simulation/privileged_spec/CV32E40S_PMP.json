[
    {
        "Requirement Location": "",
        "Feature": "Comments",
        "Sub Feature": "SmepmpOverrule",
        "Feature Description": "The \"smepmp\" spec features can overrule the \"privspec\" (e.g. for locking). Both specs are included here, so be mindful that checking of certain vplan items could be conditional.",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Comments",
        "Sub Feature": "FunctionalCoverage",
        "Feature Description": "Functional coverage is encouraged to be creative in capturing a broad set of possible state, and evaluate it towards the checkers, to catch aspects of pmp functionality that this vplan might have overlooked.",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Comments",
        "Sub Feature": "ImplementationChanges",
        "Feature Description": "If test implementation reveals new knowledge that contradicts or augments this vplan, then the vplan should be updated.",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Comments",
        "Sub Feature": "TimeAllowance",
        "Feature Description": "Some verification goals in this plan has a \"base level\" of checking plus some optional tweaks that might be tried. It is up to the testing implementation how to prioritize and potentially skip the extras, according to what time allows.",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "privspec",
        "Feature": "General",
        "Sub Feature": "Configs",
        "Feature Description": "The pmp must be tested in a wide range of configurations. That includes testing on both instruction-side and data-side, and it includes testing overlapping regions, non-overlaping, no regions, differing settings for overlapping regions, M-mode only, U-mode only, both M-mode and U-mode, etc, etc. Use functional coverage with plenty of crosses.",
        "Verification Goal": "Run with different configs to test parameters in low/mid/high ranges and in combination with the other parameters, instantiate checking on both instruction-side and data-side, write coverage to see all relevant region overlap combinations and to see an exhaustive combination of block-level input combinations and functional-level states.",
        "Pass/Fail Criteria": "Other",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "COV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "General",
        "Sub Feature": "Smepmp",
        "Feature Description": "Given 1) backwards-compatible reset values, and 2) no change in \"mseccfg\", then C) the PMP should be fully compatible with the privspec.",
        "Verification Goal": "For all privspec-derived PMP assertions, check that they must hold as long as the two preconditions hold (i.e. must not be excusable/overridable by smepmp features).",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "General",
        "Sub Feature": "UmodeAlways",
        "Feature Description": "\"PMP checks are applied to all accesses whose effective privilege mode is S or U, including instruction fetches in S and U mode, data accesses in S and U mode when the MPRV bit in the mstatus register is clear, and data accesses in any mode when the MPRV bit in mstatus is set and the MPP field in mstatus contains S or U.\"\n\nNote: None of those scenarios should let an access bypass the pmp.",
        "Verification Goal": "Set up the system to match each point in the listing, ensure that the pmp's decision matches all modelled expectations.\n\nNote: Also cover when none of the listed preconditions are active and the pmp's decision can disagree with the modelled expectations.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "General",
        "Sub Feature": "DefaultNone",
        "Feature Description": "\"PMP can grant permissions to S and U modes, which by default have none\"",
        "Verification Goal": "Check that, out of reset, given no extraordinary reset values, and given no change to the pmp csrs, then U-mode has no access permissions.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nDTC: cv32e40s/tests/programs/custom/pmp/",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "General",
        "Sub Feature": "DefaultFull",
        "Feature Description": "\"can revoke permissions from M-mode, which\nby default has full permissions\"",
        "Verification Goal": "Check that, out of reset, given no extraordinary reset values, and given no change to the pmp csrs, then M-mode has full access permissions.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nDTC: cv32e40s/tests/programs/custom/pmp/",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Csrs",
        "Sub Feature": "ResetRegisters",
        "Feature Description": "\"Writable PMP registers\u2019 A and L fields are set to 0, unless the platform mandates a different reset value for some PMP registers\u2019 A and L fields.\"",
        "Verification Goal": "Read the A and L values right after reset, ensure that the default reset values are 0.\n\nNote: Should also be visible on rvfi without specifically using csr instructions.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nDTC: cv32e40s/tests/programs/custom/pmp/",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Csrs",
        "Sub Feature": "Warl",
        "Feature Description": "\"All PMP CSR fields are WARL and may be hardwired to zero\".\n\nNote: A field shall also not change its value when an attempt is made to write an illegal value to it. (XWR is one field.)",
        "Verification Goal": "Try writing any values to the registers and read values out of them, ensure that neither reads nor writes causes exceptions, and ensure that all read values are legal or otherwise as expected and that illegally written fields don't change.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfg_expected[*].a_cfg_expected\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgwdata_legal[*].a_cfgwdata_legal\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgrdata_expected[*].a_cfgrdata_expected\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Csrs",
        "Sub Feature": "MmodeOnly",
        "Feature Description": "\"PMP CSRs are only accessible to M-mode.\"",
        "Verification Goal": "Try to access any of the pmp CSRs from U-mode, ensure that it always gives \"illegal instruction exception\" and that the CSRs are not updated.\n\nNote: M-mode accesses are covered by AlwaysAccessible below.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_csrs_mmode_only\n\nCOV: ???\n\nDTC: cv32e40s/tests/programs/custom/pmp/",
        "Comment": "TODO missing cover (combine with \"Warl\" above)"
    },
    {
        "Requirement Location": "",
        "Feature": "Csrs",
        "Sub Feature": "Addr34bit",
        "Feature Description": "\"Each PMP address register encodes bits 33\u20132 of a 34-bit physical address for RV32\"",
        "Verification Goal": "Ensure that when the pmpaddr MSBs are set, then no NAPOT accesses matches. Cover that all bits have been matched against (\"toggle cross\"). Ensure that there are no attempted accesses to MSBs that the core should not be able to use.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert\n\nTODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Csrs",
        "Sub Feature": "AddrImplemented",
        "Feature Description": "\"Not all physical address bits may be implemented, and so the pmpaddr registers are WARL.\"",
        "Verification Goal": "Cover (toggle) that all bits can be both written and set. (UnusedZero below covers the WARL(0x0) case.)",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "COV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "MatchDisabled",
        "Feature Description": "\"When A=0, this PMP entry is disabled and matches no addresses\"\nWhen a cfg is set to off but its address(es) (interpreted as napot/tor) is the only rule that matches an attempted access, then it still does not count as a match.",
        "Verification Goal": "Have a region's address(es) set up as tor and napot (separate runs), have all other regions not include the target address, have the target region's rule be OFF, make an access within that range, ensure that the outcome is the same as for when an access is outside of all address ranges.\n\nNote: For this and several other items, functional coverage is necessary because the checking doesn't necessarily have the above scenario in its antecedent.\n\nCoverage: Capture the above scenario, minus the checking.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "NapotMatching",
        "Feature Description": "\"NAPOT ranges make use of the low-order bits of the associated address register to encode the size of the range [\"yyyy...yy01\" etc]\"\n\nNote: The napot address matching modes match on addresses that are equal to the requested access when masked to the granularity size.",
        "Verification Goal": "Configure napot rules of different sizes, try accesses within and outside the regions, ensure that the outcomes corresponds to the designated sizes.\n\nNote: Includes NAPOT and NA4.\n\nNote: Try also max and min.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_na4is4byte.a_na4_is_4byte\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_cg_common.cover_item_covergroup_cg_internals_common_inst_cg_int_coverpoint_cp_napot_encoding_bin_auto[*]\ndut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_cg_common.cover_item_covergroup_cg_internals_common_inst_cg_int_coverpoint_cp_napot_encoding_disallowed_bin_auto[*]\n\nCOV: ???",
        "Comment": "TODO missing coverage"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "TorMatching",
        "Feature Description": "\"If TOR is selected, the associated address register forms the top of the address range, and the preceding PMP address register forms the bottom of the address range. If PMP entry i\u2019s A field is set to TOR, the entry matches any address y such that pmpaddri\u22121 \u2264 y < pmpaddri (irrespective  of the value of pmpcfgi\u22121)\"",
        "Verification Goal": "Configure tor regions of different sizes, try accesses within and outside the regions, ensure that the outcomes corresponds to the designated ranges.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_cg_common.cover_item_covergroup_cg_internals_common_inst_cg_int_coverpoint_cp_ismatch_tor_bin_auto[*]\n\nCOV: ???",
        "Comment": "TODO missing coverage"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "TorZero",
        "Feature Description": "\"If PMP entry 0\u2019s A field is set to TOR, zero is used for the lower bound, and so it matches any address y < pmpaddr0.\"",
        "Verification Goal": "Configure entry 0 as tor regions of different sizes, try accesses within and outside the regions, ensure that the outcomes corresponds to the designated ranges.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???\n\nDTC: cv32e40s/tests/programs/custom/pmp/",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "TorNomatch",
        "Feature Description": "\"If pmpaddri\u22121 \u2265 pmpaddri and pmpcfgi.A=TOR, then PMP entry i matches no addresses.\"",
        "Verification Goal": "Set up tor regions where the addresses are not in increasing order, try accesses on or within the designated \"reverse\" regions, ensure that they are treated as if there is no match.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???\n\nDTC: cv32e40s/tests/programs/custom/pmp/",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "SameGrain",
        "Feature Description": "\"In general, the PMP grain [...] must be the same across all PMP regions.\"",
        "Verification Goal": "Do the same as for the basic case of GranularityDetermination below, ensure that all read values are the same across all the pmp csrs.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "Na4Unselectable",
        "Feature Description": "\"When G \u2265 1, the NA4 mode is not selectable.\"",
        "Verification Goal": "Have the G parameter set to at least 1, ensure that NA4 never gets selected (even when writing to non-locked cfg).\n\nNote: Formal should easily check this.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_na4onlyg0[*].a_na4_only_g0\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_na4onlyg0[*].a_na4_only_g0\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_na4onlyg0[*].a_na4_not_when_g uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_na4onlyg0[*].a_na4_not_when_g",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "NapotImplied",
        "Feature Description": "\"When G \u2265 2 and pmpcfgi.A[1] is set, i.e. the mode is NAPOT\".",
        "Verification Goal": "(Covered by Na4Unselectable above)",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "NapotOnes",
        "Feature Description": "\"When G \u2265 2 and pmpcfgi.A[1] is set, [...] then bits pmpaddri[G-2:0] read as all ones.\"",
        "Verification Goal": "Have the G parameter set to at least 2, have A set, read pmpaddri, ensure the LSBs are all ones as specified.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_napot_ones_g2.gen_napot_ones_i[*].a_napot_ones",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "AllZeros",
        "Feature Description": "\"When G \u2265 1 and pmpcfgi.A[1] is clear, i.e. the mode is OFF or TOR, then bits pmpaddri[G-1:0] read as all zeros.\"",
        "Verification Goal": "Create the listed preconditions, ensure that the read value contains zeroes as specified.\n\nNote: Check both OFF/TOR, and for all configs fields (checking of all configs don't need 100% coverage in simulation).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_all_zeros_g1.gen_all_zeros_i[*].a_all_zeros\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "TorUnaffected",
        "Feature Description": "\"Bits pmpaddri[G-1:0] do not affect the TOR address-matching logic.\"",
        "Verification Goal": "Write different values to \"pmpaddri[G-1:0]\", ensure TOR mode matches the same either way.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "StorageUnaffected",
        "Feature Description": "\"Although changing pmpcfgi.A[1] affects the value read from pmpaddri, it does not affect the underlying value stored in that register\"\n\"in particular, pmpaddri[G-1] retains its original value when pmpcfgi.A is changed from NAPOT to TOR/OFF then back to NAPOT.\"",
        "Verification Goal": "Change in and out of (OFF || TOR) and !(OFF || TOR), ensure that different values can be read without having written anything new to the register.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_storage_unaffected[*].a_storage_unaffected\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "GranularityDetermination",
        "Feature Description": "\"Software may determine the PMP granularity by writing zero to pmp0cfg, then writing all ones to pmpaddr0, then reading back pmpaddr0. If G is the index of the least-significant bit set, the PMP granularity is 2 G+2 bytes.\"",
        "Verification Goal": "Write zero to pmpicfg, write ones to pmpaddri, read pmpaddri, ensure that the LSB index matches to granularity parameter.\n\nNote: Formal can maybe check this for all i.\n\nNote: If time allows, can write something else than zero and ensure that the rest follows as expected.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_granularity_determination",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "AddressMatching",
        "Sub Feature": "XlenMatching",
        "Feature Description": "\"If the current XLEN is greater than MXLEN, the PMP address registers are zero-extended from MXLEN to XLEN bits for the purposes of address matching.\"",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "UntilReset",
        "Feature Description": "\"Locked PMP entries remain locked until the hart is reset.\"",
        "Verification Goal": "Lock entry i (for all i, if feasible), ensure that the lock bit is never lifted before reset. (Unless if RLB interferes.)\n\nNote: Sim might do a second reset, formal most likely won't and shouldn't need to.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_until_reset[*].a_until_reset",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "IgnoreWrites",
        "Feature Description": "\"If PMP entry i is locked, writes to pmpicfg and pmpaddri are ignored.\"",
        "Verification Goal": "Lock entry i (for all i, if feasible), ensure that their value can't change, both when written to and otherwise. (Unless if RLB interferes.)",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_rlb_locked[*].a_norlb_locked_rules_cannot_modify uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_rlb_locked[*].a_norlb_locked_rules_cannot_modify\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_writes_notrap[*].a_ignore_writes_notrap\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_writes_nochange[*].a_ignore_writes_nochange\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "IgnoreTor",
        "Feature Description": "\"Additionally, if PMP entry i is locked and pmpicfg.A is set to TOR, writes to pmpaddri-1 are ignored.\"",
        "Verification Goal": "Lock entry i (\u2026), have A set and the mode be TOR, ensure that pmpaddri-1 can't change, both for explicit writes and otherwise. (Unless RLB.)",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_tor[*].a_ignore_tor_stable\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_tor[*].a_ignore_tor_wdata\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "NotIgnore",
        "Feature Description": "When neither cfg i is locked, nor is cfg i+1 a locked TOR region, then writes to cfg and addr i are not ignored.",
        "Verification Goal": "Have cfg i unlocked, write to cfg and addr csr i, check that it changes.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_addr_writes[*].a_addr_nonlocked\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_addr_tor[*].a_addr_nonlocked_tor",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "LockOff",
        "Feature Description": "\"Setting the L bit locks the PMP entry even when the A field is set to OFF.\"",
        "Verification Goal": "Lock entry i while the mode is OFF, ensure that it gets locked in this case too.\n\nNote: Ensure that checking and coverage handles locking for all possible modes.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: (Same checking as for \"IgnoreWrites\" and \"IgnoreTor\" above.)\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "RwxPrivmode",
        "Feature Description": "\"In addition to locking the PMP entry, the L bit  indicates whether the R/W/X permissions are enforced on M-mode accesses. When the L bit is set, these permissions are enforced for all privilege modes.\"",
        "Verification Goal": "Be in M-mode and U-mode (separate runs), access a region where L is set and where RWX {grant, deny R, deny W, deny X}, ensure that the access is correspondingly granted/denied.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "MmodeSucceed",
        "Feature Description": "\"When the L bit is clear, any M-mode access matching the PMP entry will succeed\"",
        "Verification Goal": "Be in M-mode, access a region where L is clear, ensure that access is granted in all cases.\n\n(Note, see \"Smepmp\" above.)",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "LockingAndPrivmode",
        "Sub Feature": "RwxUmode",
        "Feature Description": "\"When the L bit is clear [\u2026] the R/W/X permissions apply only to S and U modes.\"",
        "Verification Goal": "Be in U-mode, access a region where L is clear, ensure that access is granted/denied based on RWX.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_uorl_onlyif_rwx\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_uorl_onlyif_rwx\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "LowestDetermines",
        "Feature Description": "\"PMP entries are statically prioritized. The lowest-numbered PMP entry that matches any byte of an access determines whether that access succeeds or fails.\"\n\nNote: \"any\" byte.",
        "Verification Goal": "Access a region that is covered by multiple rules, ensure that the lowest indexed match determines the outcome.\n\nNote: Requires that the rules would disagree on the outcome.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "MatchAll",
        "Feature Description": "\"The matching PMP entry must match all bytes of an access, or the access fails, irrespective of the L, R, W, and X bits.\"",
        "Verification Goal": "(Only relevant for 64-bit architectures.)",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "LrwxDetermines",
        "Feature Description": "\"If a PMP entry matches all bytes of an access, then the L, R, W,and X bits determine whether the access succeeds or fails. [...] if the L bit is set or the privilege mode of the access is S or U, then the access succeeds only if the R, W,or X bit corresponding to the access type is set.\"",
        "Verification Goal": "Access a pmp region where L and the privmode etc is such that nothing else would deny the access, ensure that each of (or a combination of) RWX can either grant or deny the access.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_lrwx_aftermatch\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_lrwx_aftermatch\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "MmodeSucceed2",
        "Feature Description": "\"If the L bit is clear and the privilege mode of the access is M, the access succeeds.\"",
        "Verification Goal": "(Same as \"MmodeSucceed\" above)",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "MmodeNomatch",
        "Feature Description": "\"If no PMP entry matches an M-mode access, the access succeeds.\"",
        "Verification Goal": "Be in M-mode, access a region where no rule matches, ensure that the access is granted (where MMWP is off).\n\n(Note, see \"Smepmp\" above.)",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "UmodeNomatch",
        "Feature Description": "\"If no PMP entry matches an S-mode or U-mode access, but at least one PMP entry is implemented, the access fails.\"\n\nNote: \"All PMP CSRs are always implemented\".",
        "Verification Goal": "Be in U-mode, do an access that doesn't match any region, ensure that the access fails.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_nomatch_umode_fails\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_nomatch_umode_fails\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "UmodeOff",
        "Feature Description": "\"If at least one PMP entry is implemented, but all PMP entries\u2019 A fields are set to OFF, then all S-mode and U-mode memory accesses will fail.\"",
        "Verification Goal": "Be in U-mode, have all entries OFF, make an access, ensure that the access fails (for all variations of accesses).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "FailException",
        "Feature Description": "\"Failed accesses generate an instruction, load, or store access-fault exception.\"",
        "Verification Goal": "Cause failed accesses on instructions/loads/stores, ensure that an exception occurs and that it is the right one.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*\n\nA: <embedded>::uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "PriorityAndMatching",
        "Sub Feature": "MultiAccess",
        "Feature Description": "\"Note that a single instruction may generate multiple accesses, which may not be mutually atomic. An access-fault exception is generated if at least one access generated by an instruction fails, though other accesses generated by that instruction may succeed with visible side effects.\"\n\n\"On some implementations, misaligned loads, stores, and instruction fetches may also be decomposed into multiple accesses, some of which may succeed before an access-fault exception occurs. In particular, a portion of a misaligned store that passes the PMP check may become visible, even if another portion fails the PMP check.\"",
        "Verification Goal": "Induce misaligned word instruction-fetch, load, and store, where the lower and upper (separate runs) parts are either accessible or blocked by pmp, ensure that exceptions occur while parts of the access might reach the bus.\n\nAlso check Zc's push/pop and table jump.\n\nNote: It is up to other vplans to check what happens upon the exception. It is up to this PMP vplan to check that the PMP will cause the exceptions.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_splittrap\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_splittrap\n\nA: ???\n\nCOV: ???",
        "Comment": "TODO missing assert (on split that errs on first)\n\nTODO missing cover"
    },
    {
        "Requirement Location": "smepmp",
        "Feature": "MsecCfg",
        "Sub Feature": "MmodeOnly",
        "Feature Description": "\"Machine Security Configuration (mseccfg) is [...] only accessible to Machine mode.\"\n\nNote: Includes \"mseccfgh\".",
        "Verification Goal": "Access (read/write) mseccfg (and mseccfgh) from M-mode, access mseccfg from U-mode, ensure that the first always works (WARL) and the second never works (exception).\n\nNote: Cover with MPRV too.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "MsecCfg",
        "Sub Feature": "FieldsWarl",
        "Feature Description": "\"All mseccfg fields defined on this proposal are WARL\"",
        "Verification Goal": "Try writing any values to the fields (the defined ones, but also other bits) and read values out of the fields, ensure that neither reads nor writes causes exceptions, and ensure that all read values are legal or otherwise as expected.\n\nNote: This relates to the \"stickiness\" of those fields. Regardless of their values and current stickiness, the fields are WARL.\n\nNote: It might be difficult, when trying to write a checker for traps, to filter out all other causes for traps that can occur simultaneously. (Either reduce the scope of checking, or write re-usable helper signals for \"trap causality\" info.)\n\nNote: \"WPRI\" on some bits.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert\n\nTODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "MsecCfg",
        "Sub Feature": "ReservedZero",
        "Feature Description": "\"the remaining bits are reserved for future standard use and should always read zero.\"\n(This spec can't dictate that about other specs, but the user manual agrees on the hardwiring.)",
        "Verification Goal": "Read mseccfg, ensure the non-smepmp-field bits are always zero.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "MsecCfg",
        "Sub Feature": "ResetValue",
        "Feature Description": "\"The reset value of mseccfg is implementation-specific, otherwise if backwards compatibility is a requirement it should reset to zero on hard reset.\"",
        "Verification Goal": "Read the value of mseccfg right after reset, ensure that the default reset value is zero.\n\nNote: Should also be visible on rvfi without specifically using csr instructions.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_mseccfg_reset_val\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_mseccfg_reset_val",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockingBypass",
        "Sub Feature": "ModifiableEntries",
        "Feature Description": "\"When mseccfg.RLB is 1 locked PMP rules may be removed/modified and locked PMP entries may be edited.\"\n\nNote: Both \"cfg\" and \"addr\" registers, limited to fields within \"cfg\" reg, also TOR affects lower \"addr\" reg.",
        "Verification Goal": "Have a locked pmp entry i, set RLB to 1, try modifying any(!) field within {pmpicfg, pmpaddri, pmpaddri-1(tor)}, ensure that values are updated succesfully (while respecting other rules like legal values and reserved bits).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].c_rlb_locked_rules_can_modify_addr\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].c_rlb_locked_rules_can_modify_exec\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].c_rlb_locked_rules_can_modify_lock\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].c_rlb_locked_rules_can_modify_mode\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].c_rlb_locked_rules_can_modify_read\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].c_rlb_locked_rules_can_modify_write\n\nCOV: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "LockingBypass",
        "Sub Feature": "RemainZero",
        "Feature Description": "\"When mseccfg.RLB is 0 and pmpcfg.L is 1 in any rule or entry (including disabled entries), then mseccfg.RLB remains 0 and any further modifications to mseccfg.RLB are ignored until a PMP reset\"\n\nNote: \"any\" entry.",
        "Verification Goal": "Have RLB=0 and at least one L=1, ensure that RLB is 0 forever (until reset).\n\nNote: No exception occurs on attempted access, but one should try overwriting the value to stimulate the checking.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_rlb_never_fall_while_locked\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_rlb_never_fall_while_locked",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockingBypass",
        "Sub Feature": "UntilReset",
        "Feature Description": "The sticky zero and update-ignores last until reset, and do not hold after reset.",
        "Verification Goal": "Ensure that RLB is modifiable after reset. (Unless if reset values are set to activate the RemainZero condition.)",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_until_reset_notbefore\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockingBypass",
        "Sub Feature": "HardwireZero",
        "Feature Description": "\"Vendors who don\u2019t need this functionality may hardwire this field to 0.\"",
        "Verification Goal": "(40s has not hardwired this to 0, it is RW.)",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "WhiteList",
        "Sub Feature": "StickyUntilReset",
        "Feature Description": "\"[mseccfg.MMWP] is a sticky bit, meaning that once set it cannot be unset until a PMP reset.\"",
        "Verification Goal": "Have MMWP set, ensure that it remains high forever (til reset).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_mmwp_never_fall_until_reset\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_mmwp_never_fall_until_reset",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "WhiteList",
        "Sub Feature": "Denied",
        "Feature Description": "\"When set it changes the default PMP policy for M-mode when accessing memory regions that don\u2019t have a matching PMP rule, to denied instead of ignored.\"",
        "Verification Goal": "Have MMWP set, be in (effective mode) M-mode, access regions that don't match any rule (including OFF, \"reversed\" TOR, >32bit NAPOT, etc), ensure that the access is denied.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_nomatch_mmode_mmwp_fails\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_nomatch_mmode_mmwp_fails\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownGeneral",
        "Sub Feature": "StickyUntilReset",
        "Feature Description": "\"[mseccfg.MML] is a sticky bit, meaning that once set it cannot be unset until a PMP reset.\"",
        "Verification Goal": "Cover: Trying to clear the bit.\n\nCheck: Have MML set, ensure that it remains high forever (til reset).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_mml_never_fall_until_reset\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_mml_never_fall_until_reset\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownGeneral",
        "Sub Feature": "ExecIgnored",
        "Feature Description": "\"[When mseccfg.MML is set.] Adding an M-mode-only or a locked Shared-Region rule with executable privileges is not possible and such pmpcfg writes are ignored, leaving pmpcfg unchanged.\"\n\nNote: \"pmpcfg\" refers to a field, so the write to the CSR itself should still update other fields.",
        "Verification Goal": "Have MML set, try adding an \"M-mode-only\" rule and a \"locked Shared-Region\" rule with X privileges, ensure that the relevant pmpcfg field is not updated but is left unchanged, ensure also that other fields can still get updated.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgwdata_legal[*].a_cfgwdata_legal\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_rlb_locked_cov[0].a_mmode_only_or_shared_executable_ignore\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_rlb_locked_cov[0].a_mmode_only_or_shared_executable_ignore\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownGeneral",
        "Sub Feature": "ExecRlb",
        "Feature Description": "\"[The above] restriction can be temporarily lifted e.g. during the boot process, by setting mseccfg.RLB.\"",
        "Verification Goal": "Have RLB and MML set, try adding an \"M-mode-only\" rule and a \"locked Shared-Region\" rule with X privileges, ensure that the relevant pmpcfg field is in fact updated.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rlblifts_lockedexec[*].a_rlblifts_lockedexec",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownGeneral",
        "Sub Feature": "MmodeExec",
        "Feature Description": "\"Executing code with Machine mode privileges is only possible from memory regions with a matching M-mode-only rule or a locked Shared-Region rule with executable privileges. Executing code from a region without a matching rule or with a matching S/U-mode-only rule is denied.\"",
        "Verification Goal": "Execute from \"M-mode-only\" and \"locked Shared-Region\" regions, attempt execution without matching and from \"U-mode-only\" regions, ensure corresponding grant or deny.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownGeneral",
        "Sub Feature": "RwReserved",
        "Feature Description": "\"If mseccfg.MML is not set, the combination of pmpcfg.RW=01 remains reserved for future standard use.\"",
        "Verification Goal": "Whitelist the conditions that allow RW=01 (including MML conditions), ensure that it is adhered to.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rwx_mml[*].a_rwx_mml\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_rwfuture[*].a_rw_futureuse\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_rwfuture[*].a_rw_futureuse",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "MmodeEnforce",
        "Feature Description": "\"[When mseccfg.MML is set.] An M-mode-only rule is enforced on Machine mode\"",
        "Verification Goal": "Be in M-mode, have MML set, access an \"M-mode-only\" region, ensure that the grant/deny is always in accordance to the rule. (E.g. it is not denied execute despite the execute bit being set.)\n\nNote: Exclude cases of interference from e.g. PMA.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "UmodeDeny",
        "Feature Description": "\"[When mseccfg.MML is set.] An M-mode-only rule is [...] denied in Supervisor or User mode.\"",
        "Verification Goal": "Be in U-mode, have MML set, access an \"M-mode-only\" region, ensure that the access is always denied.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "RemainLocked",
        "Feature Description": "\"It also remains locked so that any further modifications to its associated configuration or address registers are ignored until a PMP reset\"\n\nCertain rules under MML are sticky. They cannot be modified again.",
        "Verification Goal": "Configure rules for {\"M-mode-only\", \"U-mode-only, \"Shared-Region rule where pmpcfg.L is set\"(both kinds)}, have MML=1 (and RLB=0), ensure that the configs never change again (until reset).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "RlbUnlocks",
        "Feature Description": "\"It also remains locked [...] unless mseccfg.RLB is set.\"",
        "Verification Goal": "Have the same setup as in RemainLocked, but let RLB=1, try changing the configs, ensure that they are indeed changed.\n\nNote: \"Assertion check\" includes cover properties.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "UmodeEnforce",
        "Feature Description": "\"[When mseccfg.MML is set.] An S/U-mode-only rule is enforced on Supervisor and User modes \"",
        "Verification Goal": "Be in U-mode, have MML=1, access a \"U-mode-only\" region, ensure that the grant/deny is in accordance with the rule (apart from PMA etc).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_cp_data_side.cg_data\n\nCOV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_cp_instr_side.cg_instr\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "MmodeDeny",
        "Feature Description": "\"An S/U-mode-only rule is [...] denied on Machine mode.\"",
        "Verification Goal": "Be in M-mode, have MML=1, access a \"U-mode-only\" region, ensure that the access is always denied.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "TODO missing coverage. (Just do a cg with crosses of all of these variables.)"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "SharedEnforced",
        "Feature Description": "\"A Shared-Region rule is enforced on all modes\"",
        "Verification Goal": "Be in M-mode and U-mode (separate runs), access a \"Shared-Region\", ensure that the grant/deny is in accordance with the rule.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "SharedNoexec",
        "Feature Description": "\"A Shared-Region rule where pmpcfg.L is not set can be used for sharing data between M-mode and S/U-mode, so is not executable.\"",
        "Verification Goal": "Be in M-mode and U-mode, try to execute from \"A Shared-Region rule where pmpcfg.L is not set\", ensure that it does not work (exception).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "MmodeReadwrite",
        "Feature Description": "\"[Shared-Region rule where pmpcfg.L is not set.] M-mode has read/write access to that region\"",
        "Verification Goal": "Be in M-mode, perform reads and writes to such a region, ensure that the intended effects happen and that the accesses do not cause exceptions.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "UmodeRead",
        "Feature Description": "\"[For a Shared-Region rule where pmpcfg.L is not set] S/U-mode has read access if pmpcfg.X is not set, or read/write access if pmpcfg.X is set.\"",
        "Verification Goal": "Be in U-mode, perform reads and writes to such a region, ensure that the reads always work and that the writes depend on X.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "SharedNowrite",
        "Feature Description": "\"A Shared-Region rule where pmpcfg.L is set can be used for sharing code between M-mode and S/U-mode, so is not writeable.\"\n\nNote: The spec is unclear here, but \"A Shared-Region rule where pmpcfg.L is set\" must refer to \"LRWX=101X\", because \"The encoding pmpcfg.LRWX=1111\" is a separate point. (This holds for the subsequent items below too.)",
        "Verification Goal": "Be in M-mode and U-mode, write to such a region, ensure that the writes do not reach the bus and that an exception occurs.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "BothExecute",
        "Feature Description": "\"Both M-mode and S/U-mode have execute access on the [Shared-Region rule where pmpcfg.L is set]\"",
        "Verification Goal": "Be in M-mode and U-mode, attempt to execute from such a region, ensure that the code is executed and that the attempt does not cause an exception.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "MmodeRead",
        "Feature Description": "\"M-mode also has read access [to Shared-Region rule where pmpcfg.L is set] if pmpcfg.X is set.\"",
        "Verification Goal": "Be in M-mode, attempt to read from such a region, ensure that the success depends accordingly on X.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: ???",
        "Comment": "(Same as for \"MmodeDeny\")"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "IgnoreUntilReset",
        "Feature Description": "\"The [Shared-Region rule where pmpcfg.L is set] remains locked so that any further modifications to its associated configuration or address registers are ignored until a PMP reset, unless mseccfg.RLB is set.\"",
        "Verification Goal": "(Covered by RemainLocked above.)",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "BothReadonly",
        "Feature Description": "\"The encoding pmpcfg.LRWX=1111 can be used for sharing data between M-mode and S/U mode, where both modes only have read-only access to the region.\"",
        "Verification Goal": "Be in M-mode and U-mode, access such a region, ensure that only the reads work and that the rest (write/execute) excepts.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal\nuvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal\n\nCOV: dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_cp_instr_side.cover_item_covergroup_cg_internals_instr_side_inst_cg_instr_coverpoint_cp_r_mmode_mml_lrwx\n\nCOV: dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_cp_data_side.cover_item_covergroup_cg_internals_data_side_inst_cg_instr_coverpoint_cp_r_mmode_mml_lrwx\n\nCOV: dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_cp_data_side.cover_item_covergroup_cg_internals_data_side_inst_cg_instr_coverpoint_cp_r_umode_mml_lrwx\n\nCOV: ???",
        "Comment": "TODO technically missing the \"the rest \u2026 excepts\" cover"
    },
    {
        "Requirement Location": "",
        "Feature": "LockdownA",
        "Sub Feature": "ReadonlyLocked",
        "Feature Description": "\"The [pmpcfg.LRWX=1111] rule remains locked so that any further modifications to its associated configuration or address registers are ignored until a PMP reset, unless mseccfg.RLB is set.\"",
        "Verification Goal": "(Covered by RemainLocked above.)",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "LegalRwx",
        "Sub Feature": "",
        "Feature Description": "Depending on the mseccfg control bits and L, some RWX combinations are reserved.\n\nNote: Use the table from the spec.",
        "Verification Goal": "Ensure that illegal/reserved mseccfg/L/RWX combinations are unreachable.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfg_expected[*].a_cfg_expected\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgwdata_legal[*].a_cfgwdata_legal\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgrdata_expected[*].a_cfgrdata_expected",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Reachable",
        "Sub Feature": "",
        "Feature Description": "All legal states in the table are reachable. It could theoretically be that platform-specific constraints made certain states unreachable (particularily related to locking), but we should be able to reach all legal and supported combinations of settings.",
        "Verification Goal": "Ensure that all legal states are reachable.",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "COV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "manual",
        "Feature": "Parameters",
        "Sub Feature": "MinimumGranularity",
        "Feature Description": "\"The PMP_GRANULARITY parameter is used to configure the minimum granularity of PMP address matching. The minimum granularity is [2^(PMP_GRANULARITY+2)] bytes, so at least 4 bytes.\"",
        "Verification Goal": "Have runs with max granularity, minimum granularity, and something in between. Make sure all checkers/covers are active for each relevant run configuration, so tor/napot/na4 is tested with different granularities. Cover cases where a match would otherwise occur but the granularity made the access not match.\n\nNote: Ensure TorMatching etc above heed this parameter.",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "COV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Parameters",
        "Sub Feature": "NumRegions",
        "Feature Description": "\"The PMP_NUM_REGIONS parameter is used to configure the number of PMP regions, starting from the lowest numbered region.\"\n\nNote: Including 0 regions.",
        "Verification Goal": "Have runs with max number, minimum number, and something in between.",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "COV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Parameters",
        "Sub Feature": "ResetValues",
        "Feature Description": "\"The reset value of the PMP CSR registers can be set through the top level parameters PMP_PMPNCFG_RV[], PMP_PMPADDR_RV[] and PMP_MSECCFG_RV.\"",
        "Verification Goal": "Have runs with different reset values. Ensure that after reset then the reset values are effectuated.\n\nNote: Try also, reset values with locked configs.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert\n\nTODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Parameters",
        "Sub Feature": "DefaultValues",
        "Feature Description": "The reset value defaults should amount to a safe config. (Including no violation of reserved bits.)",
        "Verification Goal": "(Covered by all the checks that handles the various legalities.)",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "CSRs",
        "Sub Feature": "AlwaysAccessible",
        "Feature Description": "\"All PMP CSRs are always implemented\". \"MRW\". The CSRs are M-mode accessible, and their existence does not depend on PMP_NUM_REGIONS.\n\nNote: \"All\" pmp registers, and all fields within them.",
        "Verification Goal": "Be in M-mode, access (reads/writes) all the pmp csrs, ensure that it always works without excepting (because the csrs exist and the mode is appropriate).\n\nNote: Potential overlap with CSR vplan.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Directed Non-Self-Checking",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "CSRs",
        "Sub Feature": "ReservedLegal",
        "Feature Description": "Reserved bits/fields have legal values, matching the platform-specified defaults.",
        "Verification Goal": "(Overlaps with LegalRwx and RwReservedabove.) Read all fields of all pmp-related csrs, ensure there are no unsupported values anywhere (at all times).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgrdata_expected[*].a_cfgrdata_expected",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "CSRs",
        "Sub Feature": "MseccfghZero",
        "Feature Description": "\"Hardwired to 0\"",
        "Verification Goal": "Read mseccfgh, ensure it is always 0.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "CSRs",
        "Sub Feature": "UnusedZero",
        "Feature Description": "\"CSRs (or bitfields of CSRs) related to PMP entries with number PMP_NUM_REGIONS and above are hardwired to zero.\"\n\nNote: Including upper parts of pmpcfgn and also pmpaddr.",
        "Verification Goal": "Read pmpcfg and pmpaddr csrs, ensure the values are zero as specified. Cover that the other values can be non-zero.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert\n\nTODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "CSRs",
        "Sub Feature": "Hardening",
        "Feature Description": "Certain CSRs related to the PMP shall be \"hardened\" as per Xsecure.",
        "Verification Goal": "(CSR hardening is the responsibility of the security features vplan, even the pmp-specific part of it.)",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "MicroArchitecture",
        "Sub Feature": "WaitUpdate",
        "Feature Description": "Updates to pmp configs should NOT have an effect on earlier instructions (nor on the instruction itself).\n\nNote: Potential security hole.",
        "Verification Goal": "The pmp grant/deny checking must be compared vs \"rvfi_csr_<csrname>_rdata\".\n(This will detect whether the actual pmp decision differs from what the rvfi csr data would incidate.)\n\nNote: Compare \"pc_rdata\" for execute, and \"mem_\" signals for read/write. (Might need additional decoding of \"rvfi_insn\".)",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_musttrap\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_load\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_store\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_splittrap\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_musttrap\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_cause\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_splittrap\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "MicroArchitecture",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Inject pmp csr write instructions in random testing, intermingled with all other kinds of instructions. This should include random interrupts, bus faults, random bus stalls, etc.",
        "Pass/Fail Criteria": "Check against RM",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "COV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "MicroArchitecture",
        "Sub Feature": "AffectSuccessors",
        "Feature Description": "Updates to pmp configs MUST have an effect on later instructions.\n\nNote: Potential security hole.\n\nNote: There was a known rtl bug here before (cv32e40s/issues/168).",
        "Verification Goal": "The \"rvfi_csr_<csrname>_wdata\" (masked) for pmp csrs on one instruction, must match the \"_rdata\" value of the next instruction.\n(Combined with checking grant/deny on \"_rdata\", this should ensure that the subsequent instruction has been affected by any pmp csr update.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "(Shares asserts with \"WaitUpdate\" above.)\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rvfi_csr_writes[0].a_rvfi_cfg_writes\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rvfi_csr_writes[0].a_rvfi_addr_writes",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "MicroArchitecture",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "(Same random testing as WaitUpdate above.)",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "MicroArchitecture",
        "Sub Feature": "ImplementationDetails",
        "Feature Description": "Details about pipeline/prefetcher/bus flushing etc are not part of this vplan. Only black-box observable functional behavior is checked. (Such requirements exists in specs, but are deliberately not addressed here.)",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "MicroArchitecture",
        "Sub Feature": "Performance",
        "Feature Description": "Requirements about performance and stalls etc are not covered here (unless review calls for the opposite).",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "MicroArchitecture",
        "Sub Feature": "WriteBuffer",
        "Feature Description": "Changes to the pmp config should not impact the write buffer such that a transaction can get its grant/deny status altered.",
        "Verification Goal": "Cover cases of the write buffer being full while the pmp cfg changes. Checking of accidental grants is handled by SuppressReq below. Checking of guaranteed writes is not part of this vplan.\n\nNote: The Write buffer is situated between the pmp and the bus.",
        "Pass/Fail Criteria": "Other",
        "Test Type": "Other",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "COV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "SuppressReq",
        "Feature Description": "When an access is denied by the pmp, the effect is that the attempted obi transaction is suppressed and does not reach the bus.\n\nNote: Both \"instr_req_o\" and \"data_req_o\".",
        "Verification Goal": "Observe a transaction request coming in to the pmp module, observe the pmp denying the access, ensure that the obi bus is shielded from the transaction request.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_supress_req_data.a_suppress_req_data\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_supress_req_instr.a_suppress_req_instr",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "InternalBuses",
        "Feature Description": "(The transaction request feeding into the mpu and its response signaling is not covered by this vplan.)",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "ExceptionExecute",
        "Feature Description": "\"mcause [...] Instruction access fault [...] Execution attempt with address failing PMP check.\"",
        "Verification Goal": "Attempt execution of a region that pmp denies execution of, ensure that an \"instruction access fault\" exception occurs (read mcause and rvfi signals).\n\nNote: Since ISS can check most of this, one could deprioritize this checking if it is not feasible to check within reasonable efforts. (Same for the next 2 items.)",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_cause",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "ExceptionLoad",
        "Feature Description": "\"mcause [...] Load access fault [...] Load attempt with address failing PMP check.\"\n\nNote: Holds for load-reserved too.",
        "Verification Goal": "Attempt loads (and load-reserveds) of a region that pmp denies reading from, ensure that a \"load access fault\" exception occurs (read mcause and rvfi signals).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_load\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "ExceptionStore",
        "Feature Description": "\"mcause [...] Store/AMO access fault [...] Store attempt with address failing PMP check.\"\n\nNote: Holds for store-conditional and amo too.",
        "Verification Goal": "Attempt stores (and store-conditionals and amo) to a region that pmp denies writing to, ensure that a \"store/amo access fault\" exception occurs (read mcause and rvfi signals).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_store\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "TrapPrecisely",
        "Feature Description": "\"All exceptions are precise\".\nMeaning mepc will point to the offending instruction, and exactly previous instructions have their side effects fully visible.\n\nNote: Applies to loads, stores, and executes.",
        "Verification Goal": "Observe that the pmp causes an exception, ensure that mepc points to the offending instruction.\n\nNote: Let the Exceptions vplan deal with visibility of side effects for earlier instructions. (Zc push/pop does not follow this, but that is mostly the responsibility of the Zc vplan.)\n\nNote: If satisfactory mepc checking already exist then it is acceptable to just add covers for the pmp scenarios.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert\n\nTODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "AlertMinor",
        "Feature Description": "\"The following issues result in a minor security alert: [...] Instruction access fault [...] Load access fault [...] Store/AMO access fault\"",
        "Verification Goal": "(Responsibility of the xsecure vplan. But link to coverage here too.)",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "Waiting for xsecure vplan"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "AlertNothing",
        "Feature Description": "The manual lists which pmp-related events can cause an alert minor, but the pmp should in no other cases be the cause for an alert (major/minor).\n\nNote: Example, \"attempt to reprogram a locked PMP\"",
        "Verification Goal": "Observe an alert signal going high while there is no pmp error that should have caused it, ensure that another viable reason for the alert was present.\n\nNote: This is slightly out of scope for this vplan, so if it is not very easy to hook on to existing xsecure (helper-)signals then this can be skipped.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "SplitLoadRegfile",
        "Feature Description": "Even if parts of a split load can reach the bus, the instruction itself has failed and so the regfile should not get updated.",
        "Verification Goal": "(Handled by \"SplitLoadException\" below, because: One only needs to show that an exception is caused, and the exceptions vplan is responsible for checking what that means for the regfile. (But link to coverage here too.))",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "Waiting for exceptions vplan"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "SplitLoadException",
        "Feature Description": "For split loads, regardless of which of the access that fails, the instruction should still cause an exception.",
        "Verification Goal": "Perform a misaligned load that translates to multiple accesses, let any of the accesses be denied by pmp, ensure an exception occurs.\n\nCoverage: See rvfi retire with exception cause from pmp, while the \"low addr\" model checking gave access granted.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert\n\nTODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "FirstFail",
        "Feature Description": "If a split load/store fails on its first transaction it should get an exception immediately, so it should not allow the second transaction reach the bus and mcause shall reflect the failing transactions.",
        "Verification Goal": "Attempt such an instruction, ensure that the denied access does not reach the bus, ensure that following accesses also do not reach the bus.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "PushPop",
        "Feature Description": "If a push/pop fails on a transaction it should get an exception immediately, so the remaining transactions should not reach the bus and mcause shall reflect the failing transaction.",
        "Verification Goal": "(Responsibility of the zc vplan. But link to coverage here too.)\n\nNote: Could write a pmp-specific cover, but coordinate with Zc vplan to ensure the checker is written too.",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "Waiting for zc vplan"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "TableJump",
        "Feature Description": "PMP applies to table jumps and Zc instructions in general.",
        "Verification Goal": "(Responsibility of the zc vplan. But link to coverage here too.)\n\nNote: Could write a pmp-specific cover, but coordinate with Zc vplan to ensure the checker is written too.",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "Waiting for zc vplan"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "ClicVector",
        "Feature Description": "Similarly to TableJump above, CLIC vector fetch needs execute permission.",
        "Verification Goal": "(Analogous to TableJump above.)",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "Waiting for clic vplan"
    },
    {
        "Requirement Location": "",
        "Feature": "Violations",
        "Sub Feature": "Priority",
        "Feature Description": "Exceptions priority apply to the PMP as well. Particularily, PMP exception (instruction access fault) gets priority over bus errors (instruction bus fault) if an instruction is the result of two fetches were both of these occurred.\n\nNote: Both could be present in an attempted executed instruction at the same time, because no exception occurs before the point of execution so there is enough time for both to be captured and travel through the pipeline.",
        "Verification Goal": "Keep track of words fetched with bus error and with pmp execute denied, check retired instructions for a pc that overlaps two such fetches (cover both orders), ensure that \"instruction access fault\" is the taken exception.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???\n\nCOV: ???",
        "Comment": "TODO missing assert\n\nTODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Pma",
        "Sub Feature": "RevokeExecutable",
        "Feature Description": "Even if the pma should allow for execution, the pmp can overrule it and deny access.",
        "Verification Goal": "Set up pma and pmp regions such that both have rules covering the same addresses, let the pma allow for execution, let the pmp deny it, attempt execution, ensure that execution is indeed denied.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Pma",
        "Sub Feature": "RemainNonexecutable",
        "Feature Description": "If the pma disallows execution, the pmp cannot change this fact and execution remains disallowed.",
        "Verification Goal": "Set up pma and pmp regions such that both have rules covering the same addresses, let the pma disallow execution, let the pmp allow and deny execution (separate runs), attempt execution, ensure that execution is denied.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Pma",
        "Sub Feature": "RevokePermissible",
        "Feature Description": "Even if the pma allows for data access, the pmp can overrule it and deny access.",
        "Verification Goal": "Set up pma and pmp regions such that both have rules covering the same addresses, let the pma allow for read and write (separate or same runs), let pmp deny read/write, attempt read/write, ensure that the pmp can overrule the pma.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Pma",
        "Sub Feature": "RemainNonpermissible",
        "Feature Description": "If the pma disallows data access, the pmp cannot change this fact and data access remains disallowed.",
        "Verification Goal": "Set up pma and pmp regions such that both have rules covering the same addresses, let the pma deny read and write, let pmp allow or deny it, attempt read/write, ensure that the access is always denied.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "misc",
        "Feature": "Misc",
        "Sub Feature": "DisallowDebug",
        "Feature Description": "The PMP can deny usage of debug mode by setting up regions for dm_halt_addr and dm_exception_addr.",
        "Verification Goal": "Set up pmp rules so all D-mode entries are blocked from execution, attempt to enter debug mode, ensure that nohing is executed in debug mode.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Directed Non-Self-Checking",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "Waiting for ongoing spec changes to be resolved"
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "40x",
        "Feature Description": "The 40x does not have PMP.",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "Xif",
        "Feature Description": "The X-interface can do memory operations, but the 40x does not have PMP and the 40s does not have XIF.",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "RvfiReliable",
        "Feature Description": "Rvfi is used for checking some pmp functionality, so the link between rvfi and pmp must be checked.",
        "Verification Goal": "If feasible to model within reasonable effort, check that 1) the PMPs' privmode inputs and 2) CSRs and 3) wdata/wmask is for csr write instrs, are properly correlated between access attempts and rvfi reportings.\nOtherwise, leave this to general ISS checking.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*\n\n(Indirectly checked by those asserts)",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "RvfiTrap",
        "Feature Description": "The \"rvfi_trap\" table has PMP-specific fields.",
        "Verification Goal": "Augment the exception checkers above with checking of \"rvfi_trap.cause_type\" to ensure that specifically PMP is reported as the cause.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "UntilReset",
        "Feature Description": "Everything that can get locked \"until reset\" must be possible to change after a reset. It should not be possible that these settings lock up so even resets cannot unlock them.\n\nNote: Formal's reset analysis should in principle be able to find every state that is possible to be in after a reset.",
        "Verification Goal": "(Covered by ResetValues above. As long as those always take effect out of reset, then a permanent lock up should be either impossible or intentional.)",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "Xsecure",
        "Feature Description": "(Will be covered by its own vplan.)",
        "Verification Goal": "N/A",
        "Pass/Fail Criteria": "N/A",
        "Test Type": "N/A",
        "Coverage Method": "N/A",
        "High Priority?": "",
        "Link to Coverage": "N/A",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "Reset",
        "Feature Description": "The PMP module is never reset without the whole core being reset. (As this could lift all the locks and stickies and grant privilege escalation.)",
        "Verification Goal": "Check that the core's reset is always equal to the pmp module's reset.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "ENV capability, not specific test",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "",
        "Feature": "Misc",
        "Sub Feature": "UmodeZeroRegions",
        "Feature Description": "If the parameters are set to have 0 pmp regions, then all rules are OFF and U-mode matches nothing and defaults to not have any access.",
        "Verification Goal": "Be in U-mode, have PMP_NUM_REGIONS=0, ensure all accesses fail (read/write/execute).",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Assertion Coverage",
        "High Priority?": "",
        "Link to Coverage": "A: ???",
        "Comment": "TODO missing assert"
    },
    {
        "Requirement Location": "debug",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "\"All operations are executed with machine mode privilege\".\nIt is mostly the responsibility of other vplans to check D-mode relationship to M-mode and U-mode, but the pmp inputs should be checked against debug mode.\n\nNote: Refer to user-mode vplan and debug vplan if necessary.\n\nNote: It is assumed that once 1) dmode is shown to be interpreted as mmode by pmp, and 2) all mmode features are verified, then C) the mmode features will work in dmode. But one alternative is to duplicate all the mmode-related checking with dmode variants.",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "Assertion Check",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "High Priority?": "High Priority",
        "Link to Coverage": "A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*\n\nA: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*\n\n(Indirectly checked by those asserts, together with effective priv mode and umode asserts for dmode/mmode.)\n\nCOV: ???",
        "Comment": "TODO missing cover"
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": "",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    },
    {
        "Requirement Location": " -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- END -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        "Feature": "Mmode",
        "Sub Feature": "",
        "Feature Description": "",
        "Verification Goal": "Ensure that the PMP inputs receive the correct mode while in D-mode.\n\nNote: Test w/wo MPRV too.",
        "Pass/Fail Criteria": "",
        "Test Type": "",
        "Coverage Method": "",
        "High Priority?": "",
        "Link to Coverage": "",
        "Comment": ""
    }
]