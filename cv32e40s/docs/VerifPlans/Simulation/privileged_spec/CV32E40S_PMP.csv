Requirement Location,Feature,Sub Feature,Feature Description,Verification Goal,Pass/Fail Criteria,Test Type,Coverage Method,High Priority?,Link to Coverage,Comment
N/A,Comments,SmepmpOverrule,"""smepmp"" features can overrule the ""privspec"" (e.g. locking). Both specs are included here, so be aware that certain vplan items are conditional.",N/A,N/A,N/A,N/A,No,N/A,
,,FunctionalCoverage,"Functional coverage should capture a broad set of possible state (could be compared with the checkers), to find crosses that this vplan might have overlooked.",N/A,N/A,N/A,N/A,No,N/A,
,,ImplementationChanges,"If test implementation gains new knowledge, then update this vplan when appropriate.",N/A,N/A,N/A,N/A,No,N/A,
,,TimeAllowance,"Some of the verification goals have a ""base level"" of checking plus optional tweaks. It is up to implementation to prioritize and potentially skip the extras.",N/A,N/A,N/A,N/A,No,N/A,
privspec,General,Configs,"The pmp must be tested in a wide range of configurations. That includes testing on both instruction-side and data-side, and it includes testing overlapping regions, non-overlaping, no regions, differing settings for overlapping regions, M-mode only, U-mode only, both M-mode and U-mode, etc, etc. Use functional coverage with plenty of crosses.","Run with different configs to test parameters in low/mid/high ranges and in combination with the other parameters, instantiate checking on both instruction-side and data-side.

Cover: see all relevant region overlap combinations and to see an exhaustive combination of block-level input combinations and functional-level states.",Other,"ENV capability, not specific test",Functional Coverage,No,COV: (SKIPPED),Skipped in favor of using realease-specific configs.
,,Smepmp,"Given 1) backwards-compatible reset values, and 2) no change in ""mseccfg"", then C) the PMP should be fully compatible with the privspec.","For all privspec-derived PMP assertions, check that they must hold as long as the two preconditions hold (i.e. must not be excusable/overridable by smepmp features).",Other,Other,N/A,No,(SKIPPED),Skipped in favor of considering the normal assertions good enough and using release-specific configs.
,,UmodeAlways,"""PMP checks are applied to all accesses whose effective privilege mode is S or U, including instruction fetches in S and U mode, data accesses in S and U mode when the MPRV bit in the mstatus register is clear, and data accesses in any mode when the MPRV bit in mstatus is set and the MPP field in mstatus contains S or U.""

Note: None of those scenarios should let an access bypass the pmp.","Set up the system to match each point in the listing, ensure that the pmp's decision matches all modelled expectations.

Cover: when none of the listed preconditions are active and the pmp's decision can disagree with the modelled expectations.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*

COV: (SKIPPED)","(Same as for ""MmodeDeny"")

Cover is skipped because it is not essential, and we have equivalence checking of RTL vs model."
,,DefaultNone,"""PMP can grant permissions to S and U modes, which by default have none""","Given:
1) out of reset,
2) no extraordinary reset values,
3) no change to the pmp csrs.

Then:
U-mode has no access permissions. (I.e. always excepts.)",Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"A: (SKIPPED).

DTC: cv32e40s/tests/programs/custom/pmp/","Skipped in favor of using realease-specific configs (which have ""extraordinary reset values"")."
,,DefaultFull,"""can revoke permissions from M-mode, which
by default has full permissions""","Check that, out of reset, given no extraordinary reset values, and given no change to the pmp csrs, then M-mode has full access permissions.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,No,"A: (SKIPPED)

DTC: cv32e40s/tests/programs/custom/pmp/",Skipped in favor of the directed test and the entire test suite in general.
,Csrs,ResetRegisters,"""Writable PMP registers’ A and L fields are set to 0, unless the platform mandates a different reset value for some PMP registers’ A and L fields.""","Read the A and L values right after reset, ensure that the default reset values are 0.

Note: Should also be visible on rvfi without specifically using csr instructions.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,No,"A: (SKIPPED)

DTC: cv32e40s/tests/programs/custom/pmp/","Skipped in favor of integration-level testing w/ release-specific configs, and the directed test."
,,Warl,"""All PMP CSR fields are WARL and may be hardwired to zero"".

Note: A field shall also not change its value when an attempt is made to write an illegal value to it. (XWR is one field.)","Try writing any values to the registers and read values out of them.
Ensure that neither reads nor writes causes exceptions.
And ensure that all read values are legal or otherwise as expected and that illegally written fields don't change.

Cover: access to all CSRs and all fields.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfg_expected[*].a_cfg_expected

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgwdata_legal[*].a_cfgwdata_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgrdata_expected[*].a_cfgrdata_expected

COV: (SKIPPED)",Cover skipped because the asserts are deemed sufficient.
,,MmodeOnly,"""PMP CSRs are only accessible to M-mode.""","Try to access any of the pmp CSRs from U-mode, ensure that it always gives ""illegal instruction exception"" and that the CSRs are not updated.

Cover: For all CSRs.

Note: M-mode accesses are covered by AlwaysAccessible below.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_csrs_mmode_only

COV: (SKIPPED)

DTC: cv32e40s/tests/programs/custom/pmp/",Cover skipped because the asserts and directed test are deemed sufficient.
,,Addr34bit,"""Each PMP address register encodes bits 33–2 of a 34-bit physical address for RV32""","Ensure that when the two pmpaddr MSBs are set, then no NAPOT accesses matches.
Ensure that there are no attempted accesses to MSBs that the core should not be able to use.

Cover: all bits have been matched against (""toggle cross"").",Assertion Check,Constrained-Random,Functional Coverage,No,"A: (SKIPPED).

COV: (SKIPPED)",Assert and cover skipped in favor of model equivalence checking.
,,AddrImplemented,"""Not all physical address bits may be implemented, and so the pmpaddr registers are WARL.""","Cover: (toggle) that all bits can be both written and set.

(""UnusedZero"" below covers the WARL(0x0) case.)",Other,Constrained-Random,Functional Coverage,High Priority,COV: (SKIPPED),Skipped in favor of integration-level testing w/ release-specific configs.
,AddressMatching,MatchDisabled,"""When A=0, this PMP entry is disabled and matches no addresses""
When a cfg is set to off but its address(es) (interpreted as napot/tor) is the only rule that matches an attempted access, then it still does not count as a match.","Have a region's address(es) set up as tor and napot (separate runs),
have all other regions not include the target address,
have the target region's rule be OFF,
make an access within that range,
ensure that the outcome is the same as for when an access is outside of all address ranges.

Note: For this and several other items, functional coverage is necessary because the checking doesn't necessarily have the above scenario in its antecedent.

Coverage: Capture the above scenario, minus the checking.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A:
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)","Cover is skipped in favor of integration-level testing w/ release-specific configs, because we have equivalence checking of RTL vs model."
,,NapotMatching,"""NAPOT ranges make use of the low-order bits of the associated address register to encode the size of the range [""yyyy...yy01"" etc]""

Note: The napot address matching modes match on addresses that are equal to the requested access when masked to the granularity size.","Configure napot rules of different sizes.
Try accesses within and outside the regions.
Ensure that the outcomes corresponds to the designated sizes.

Note: Includes NAPOT and NA4.

Cover: Matching inside / outside.

Cover: Min / Max of the ""yyy..."" patterns.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_na4is4byte.a_na4_is_4byte

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_cg_common.cover_item_covergroup_cg_internals_common_inst_cg_int_coverpoint_cp_napot_encoding_bin_auto[*]

COV: dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_cg_common.cover_item_covergroup_cg_internals_common_inst_cg_int_coverpoint_cp_napot_encoding_disallowed_bin_auto[*]

COV: (SKIPPED).",Cover skipped (min/max) in favor of model equivalence checking and trusting formal's capability of exercising the asserts.
,,TorMatching,"""If TOR is selected, the associated address register forms the top of the address range, and the preceding PMP address register forms the bottom of the address range. If PMP entry i’s A field is set to TOR, the entry matches any address y such that pmpaddri−1 ≤ y < pmpaddri (irrespective  of the value of pmpcfgi−1)""","Configure tor regions of different sizes.
Try accesses within and outside the regions.
Ensure that the outcomes correspond to the designated ranges.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_cg_common.cover_item_covergroup_cg_internals_common_inst_cg_int_coverpoint_cp_ismatch_tor_bin_auto[*]",
,,TorZero,"""If PMP entry 0’s A field is set to TOR, zero is used for the lower bound, and so it matches any address y < pmpaddr0.""","Configure entry 0 as tor regions of different sizes, try accesses within and outside the regions, ensure that the outcomes corresponds to the designated ranges.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)

DTC: cv32e40s/tests/programs/custom/pmp/",Cover skipped in favor of directed test and equivalence checking vs model.
,,TorNomatch,"""If pmpaddri−1 ≥ pmpaddri and pmpcfgi.A=TOR, then PMP entry i matches no addresses.""","Set up tor regions where the addresses are not in increasing order, try accesses on or within the designated ""reverse"" regions, ensure that they are treated as if there is no match.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)

DTC: cv32e40s/tests/programs/custom/pmp/",Cover skipped in favor of directed test and equivalence checking vs model.
,,SameGrain,"""In general, the PMP grain [...] must be the same across all PMP regions.""","Do the same as for the basic case of GranularityDetermination below, ensure that all read values are the same across all the pmp csrs.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,No,A: (SKIPPED),Assert skipped in favor of the asserts checking the grain in general and model equivalence checking.
,,Na4Unselectable,"""When G ≥ 1, the NA4 mode is not selectable.""","Have the G parameter set to at least 1, ensure that NA4 never gets selected (even when writing to non-locked cfg).

Note: Formal should easily check this.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_na4onlyg0[*].a_na4_only_g0
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_na4onlyg0[*].a_na4_only_g0

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_na4onlyg0[*].a_na4_not_when_g uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_na4onlyg0[*].a_na4_not_when_g",
,,NapotImplied,"""When G ≥ 2 and pmpcfgi.A[1] is set, i.e. the mode is NAPOT"".",(Covered by Na4Unselectable above),Other,Other,N/A,High Priority,N/A,
,,NapotOnes,"""When G ≥ 2 and pmpcfgi.A[1] is set, [...] then bits pmpaddri[G-2:0] read as all ones.""","Have the G parameter set to at least 2, have A set, read pmpaddri, ensure the LSBs are all ones as specified.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_napot_ones_g2.gen_napot_ones_i[*].a_napot_ones,
,,AllZeros,"""When G ≥ 1 and pmpcfgi.A[1] is clear, i.e. the mode is OFF or TOR, then bits pmpaddri[G-1:0] read as all zeros.""","Create the listed preconditions, ensure that the read value contains zeroes as specified.

Note: Check both OFF/TOR, and for all configs fields (checking of all configs don't need 100% coverage in simulation).",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_all_zeros_g1.gen_all_zeros_i[*].a_all_zeros

COV: uvmt_cv32e40s_pmp_assert.sv,  ""cp_ismatch_tor"".

COV: uvmt_cv32e40s_pmp_assert.sv, ""cov_rlb_locked_rules_can_remove"".",(The covers are written for a different purpose but should sufficiently hit this.)
,,TorUnaffected,"""Bits pmpaddri[G-1:0] do not affect the TOR address-matching logic.""","Write different values to ""pmpaddri[G-1:0]"", ensure TOR mode matches the same either way.",Assertion Check,Constrained-Random,Assertion Coverage,No,A: (SKIPPED),Assert skipped in favor of  model equivalence checking.
,,StorageUnaffected,"""Although changing pmpcfgi.A[1] affects the value read from pmpaddri, it does not affect the underlying value stored in that register""
""in particular, pmpaddri[G-1] retains its original value when pmpcfgi.A is changed from NAPOT to TOR/OFF then back to NAPOT.""","Change in and out of (OFF || TOR) and !(OFF || TOR), ensure that different values can be read without having written anything new to the register.

Cover: All transitions, na4/napot -> off/tor.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_storage_unaffected[*].a_storage_unaffected

COV: (SKIPPED)",Cover skipped because assert is deemed sufficient.
,,GranularityDetermination,"""Software may determine the PMP granularity by writing zero to pmp0cfg, then writing all ones to pmpaddr0, then reading back pmpaddr0. If G is the index of the least-significant bit set, the PMP granularity is 2 G+2 bytes.""","Write zero to pmpicfg, write ones to pmpaddri, read pmpaddri, ensure that the LSB index matches to granularity parameter.

Note: Formal can maybe check this for all i.

Note: If time allows, can write something else than zero and ensure that the rest follows as expected.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_granularity_determination,
,,XlenMatching,"""If the current XLEN is greater than MXLEN, the PMP address registers are zero-extended from MXLEN to XLEN bits for the purposes of address matching.""",N/A,N/A,N/A,N/A,No,N/A,
,LockingAndPrivmode,UntilReset,"""Locked PMP entries remain locked until the hart is reset.""","Lock entry i (for all i, if feasible), ensure that the lock bit is never lifted before reset. (Unless if RLB interferes.)

Note: Sim might do a second reset, formal most likely won't and shouldn't need to.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_until_reset[*].a_until_reset,
,,IgnoreWrites,"""If PMP entry i is locked, writes to pmpicfg and pmpaddri are ignored.""","Lock entry i (for all i, if feasible), ensure that their value can't change. (Unless if RLB interferes.)

Cover: both when written to and otherwise.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_rlb_locked[*].a_norlb_locked_rules_cannot_modify uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_rlb_locked[*].a_norlb_locked_rules_cannot_modify

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_writes_notrap[*].a_ignore_writes_notrap

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_writes_nochange[*].a_ignore_writes_nochange

COV: (SKIPPED)",Cover skipped because the asserts are deemed sufficient.
,,IgnoreTor,"""Additionally, if PMP entry i is locked and pmpicfg.A is set to TOR, writes to pmpaddri-1 are ignored.""","Lock entry i (…), have A set and the mode be TOR, ensure that pmpaddri-1 can't change. (Unless RLB.)

Cover: both for explicit writes and otherwise",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_tor[*].a_ignore_tor_stable

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_ignore_tor[*].a_ignore_tor_wdata

COV: (SKIPPED)",Cover skipped because the asserts are deemed sufficient.
,,NotIgnore,"When neither cfg i is locked, nor is cfg i+1 a locked TOR region, then writes to cfg and addr i are not ignored.","Have cfg i unlocked,
write to cfg and addr csr i,
check that it changes.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_addr_writes[*].a_addr_nonlocked

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_addr_tor[*].a_addr_nonlocked_tor",
,,LockOff,"""Setting the L bit locks the PMP entry even when the A field is set to OFF.""","Lock entry i while the mode is OFF, ensure that it gets locked in this case too.

Note: Ensure that checking and coverage handles locking for all possible modes.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: (Same checking as for ""IgnoreWrites"" and ""IgnoreTor"" above.)

COV: (SKIPPED).","Cover skipped, trusting formal to exercise the assert."
,,RwxPrivmode,"""In addition to locking the PMP entry, the L bit  indicates whether the R/W/X permissions are enforced on M-mode accesses. When the L bit is set, these permissions are enforced for all privilege modes.""","Be in M-mode and U-mode (separate runs),
access a region where L is set and where RWX {grant, deny R, deny W, deny X},
ensure that the access is correspondingly granted/denied.

Cover: grant, deny R, deny W, deny X.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)",Cover skipped because the asserts are deemed sufficient.
,,MmodeSucceed,"""When the L bit is clear, any M-mode access matching the PMP entry will succeed""","Be in M-mode, access a region where L is clear, ensure that access is granted in all cases.

(Note, see ""Smepmp"" above.)",Assertion Check,Constrained-Random,Assertion Coverage,No,A: (SKIPPED),Assert skipped in favor of Smepmp-based assertions.
,,RwxUmode,"""When the L bit is clear […] the R/W/X permissions apply only to S and U modes.""","Be in U-mode, access a region where L is clear, ensure that access is granted/denied based on RWX.

Cover: granted / denied.

Note: The M-mode part of this is handled by ""MmodeSucceed"" above.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_uorl_onlyif_rwx

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_uorl_onlyif_rwx

COV: (SKIPPED)",Cover skipped because the asserts are deemed sufficient.
,PriorityAndMatching,LowestDetermines,"""PMP entries are statically prioritized. The lowest-numbered PMP entry that matches any byte of an access determines whether that access succeeds or fails.""

Note: ""any"" byte.","Access a region that is covered by multiple rules, ensure that the lowest indexed match determines the outcome.

Note: Requires that the rules would disagree on the outcome. (One rule allows, other disallows.)

Cover: ""winning"" rule allows / disallows.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED).","Cover skipped, trusting formal to exercise the assert."
,,MatchAll,"""The matching PMP entry must match all bytes of an access, or the access fails, irrespective of the L, R, W, and X bits.""",(Only relevant for 64-bit architectures.),N/A,N/A,N/A,No,N/A,
,,LrwxDetermines,"""If a PMP entry matches all bytes of an access, then the L, R, W,and X bits determine whether the access succeeds or fails. [...] if the L bit is set or the privilege mode of the access is S or U, then the access succeeds only if the R, W,or X bit corresponding to the access type is set.""","Access a pmp region where L and the privmode etc is such that nothing else would deny the access, ensure that each of (or a combination of) RWX can either grant or deny the access.

Cover: U, M, L, grant, deny R, deny W, deny X, etc.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_lrwx_aftermatch

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_lrwx_aftermatch

COV: (SKIPPED)","Cover skipped because the asserts are deemed sufficient. It is partially covered already by the ""general"" covergroup and its crosses."
,,MmodeSucceed2,"""If the L bit is clear and the privilege mode of the access is M, the access succeeds.""","(Same as ""MmodeSucceed"" above)",Other,Other,N/A,No,N/A,
,,MmodeNomatch,"""If no PMP entry matches an M-mode access, the access succeeds.""","Be in M-mode,
access a region where no rule matches,
ensure that the access is granted (where MMWP is off).

Cover: the checker is generic, so cover this specific scenario.

(Note, see ""Smepmp"" above.)",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

COV: uvmt_cv32e40s_pmp_assert.sv, ""cp_x_mmode_nomatch_nommwp_x"".

COV: uvmt_cv32e40s_pmp_assert.sv, ""cp_r_mmode_nomatch_nommwp_r"".

COV: uvmt_cv32e40s_pmp_assert.sv, ""cp_w_mmode_nomatch_nommwp_w"".",
,,UmodeNomatch,"""If no PMP entry matches an S-mode or U-mode access, but at least one PMP entry is implemented, the access fails.""

Note: ""All PMP CSRs are always implemented"".","Be in U-mode, do an access that doesn't match any region, ensure that the access fails.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_nomatch_umode_fails

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_nomatch_umode_fails",
,,UmodeOff,"""If at least one PMP entry is implemented, but all PMP entries’ A fields are set to OFF, then all S-mode and U-mode memory accesses will fail.""","Be in U-mode,
have all entries OFF,
make an access,
ensure that the access fails.

Cover: this specific scenario.

Cover: for all variations of accesses",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_umode_off"".

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)","Second cover skipped because it should be the responsibility of the ""general"" covergroup and its crosses."
,,FailException,"""Failed accesses generate an instruction, load, or store access-fault exception.""","Cause failed accesses on instructions/loads/stores, ensure that an exception occurs and that it is the right one.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*

A: <embedded>::uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*",
,,MultiAccess,"""Note that a single instruction may generate multiple accesses, which may not be mutually atomic. An access-fault exception is generated if at least one access generated by an instruction fails, though other accesses generated by that instruction may succeed with visible side effects.""

""On some implementations, misaligned loads, stores, and instruction fetches may also be decomposed into multiple accesses, some of which may succeed before an access-fault exception occurs. In particular, a portion of a misaligned store that passes the PMP check may become visible, even if another portion fails the PMP check.""","Induce misaligned word instruction-fetch, load, and store, where the lower and upper (separate runs) parts are either accessible or blocked by pmp, ensure that exceptions occur while parts of the access might reach the bus.

Cover: upper/lower blocked/allowed.

Cover: parts reaching the bus.

Cover: push/pop and table jump.

Note: It is up to other vplans to check what happens upon the exception. It is up to this PMP vplan to check that the PMP will cause the exceptions.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec*

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore*

A: (SKIPPED)

COV: (SKIPPED)","Assert skipped (explicitly, split that errs on first) because it is theoretically covered by the generic assert.

Specific covers skipped, in favor of trusting formal's ability to exercise the asserts."
smepmp,MsecCfg,MmodeOnly,"""Machine SECurity ConFiGuration (mseccfg) is [...] only accessible to Machine mode.""

Note: Includes ""mseccfgh"".","Access (read/write) mseccfg (and mseccfgh) from M-mode, access mseccfg from U-mode, ensure that the first always works (WARL) and the second never works (exception).

Note: Cover with MPRV too.

Cover: read/write, mmode/umode, mprv/no, mseccfg/mseccfgh.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_csrs_mmode_only"".

COV: (SKIPPED)","Cover skipped, trusting formal to exercise the assert."
,,FieldsWarl,"""All mseccfg fields defined on this proposal are WARL""","Try writing any values to the fields (the defined ones, but also other bits) and read values out of the fields, ensure that neither reads nor writes causes exceptions, and ensure that all read values are legal or otherwise as expected.

Note: This relates to the ""stickiness"" of those fields. Regardless of their values and current stickiness, the fields are WARL.

Note: ""WPRI"" on some bits.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_csrs_mmode_only"".

A: (SKIPPED)

COV: (SKIPPED)","Second assert skipped because the features themselves are covered by other asserts and integration testing.

Cover skipped for the same reasons as the assert and also because the covergroups in uvmt_cv32e40s_pmp_assert.sv covers parts of it."
,,ReservedZero,"""the remaining bits are reserved for future standard use and should always read zero.""

(Note: This spec can't dictate that about other specs, but the user manual agrees on the hardwiring.)","Read mseccfg, ensure the non-smepmp-field bits are always zero.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_pmp_assert.sv, ""a_reserved_zero_mseccfg_fields"".",
,,ResetValue,"""The reset value of mseccfg is implementation-specific, otherwise if backwards compatibility is a requirement it should reset to zero on hard reset.""","Read the value of mseccfg right after reset, ensure that the default reset value is zero.

Note: Should also be visible on rvfi without specifically using csr instructions.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_mseccfg_reset_val

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_mseccfg_reset_val",
,LockingBypass,ModifiableEntries,"""When mseccfg.RLB is 1 locked PMP rules may be removed/modified and locked PMP entries may be edited.""

Note: Both ""cfg"" and ""addr"" registers, limited to fields within ""cfg"" reg, also TOR affects lower ""addr"" reg.","Have a locked pmp entry i, set RLB to 1, try modifying any(!) field within {pmpicfg, pmpaddri, pmpaddri-1(tor)}, ensure that values are updated succesfully (while respecting other rules like legal values and reserved bits).",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: N/A

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].cov_rlb_locked_rules_can_modify_addr

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].cov_rlb_locked_rules_can_modify_exec

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].cov_rlb_locked_rules_can_modify_lock

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].cov_rlb_locked_rules_can_modify_mode

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].cov_rlb_locked_rules_can_modify_read

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.*.gen_rlb_locked_cov[*].cov_rlb_locked_rules_can_modify_write

COV: uvmt_cv32e40s_pmp_assert.sv, ""cov_rlb_locked_rules_can_modify_tor"".",The assert is N/A because the covers are the checkers.
,,RemainZero,"""When mseccfg.RLB is 0 and pmpcfg.L is 1 in any rule or entry (including disabled entries), then mseccfg.RLB remains 0 and any further modifications to mseccfg.RLB are ignored until a PMP reset""

Note: ""any"" entry.","Have RLB=0 and at least one L=1, ensure that RLB is 0 forever (until reset).

Note: No exception occurs on attempted access, but one should try overwriting the value to stimulate the checking.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_rlb_never_fall_while_locked

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_rlb_never_fall_while_locked",
,,UntilReset,"The sticky zero and update-ignores last until reset, and do not hold after reset.","Ensure that RLB is modifiable after reset. (Unless if reset values are set to activate the RemainZero condition.)

Note: Both enable / disable.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_until_reset_notbefore,
,,HardwireZero,"""Vendors who don’t need this functionality may hardwire this field to 0.""","(40s has not hardwired this to 0, it is RW.)",N/A,N/A,N/A,No,N/A,
,WhiteList,StickyUntilReset,"""[mseccfg.MMWP] is a sticky bit, meaning that once set it cannot be unset until a PMP reset.""","Have MMWP set, ensure that it remains high forever (til reset).",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_mmwp_never_fall_until_reset

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_mmwp_never_fall_until_reset",
,,Denied,"""When set it changes the default PMP policy for M-mode when accessing memory regions that don’t have a matching PMP rule, to denied instead of ignored.""","Have MMWP set,
be in (effective mode) M-mode,
access regions that don't match any rule (including OFF, ""reversed"" TOR, >32bit NAPOT, etc),
ensure that the access is denied.

Cover: MPRV/no, off/reversed/napot.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_nomatch_mmode_mmwp_fails

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_nomatch_mmode_mmwp_fails

COV: (SKIPPED)",Cover skipped because assert is deemed sufficient.
,LockdownGeneral,StickyUntilReset,"""[mseccfg.MML] is a sticky bit, meaning that once set it cannot be unset until a PMP reset.""","Check: Have MML set, ensure that it remains high forever (til reset).

Cover: Trying to clear the bit.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_pmp_assert.a_mml_never_fall_until_reset

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_mml_never_fall_until_reset

COV: (Skipped)",Cover skipped because assert is deemed sufficient.
,,ExecIgnored,"""[When mseccfg.MML is set.] Adding an M-mode-only or a locked Shared-Region rule with executable privileges is not possible and such pmpcfg writes are ignored, leaving pmpcfg unchanged.""

Note: ""pmpcfg"" refers to a field, so the write to the CSR itself should still update other fields.","Have MML set,
try adding an ""M-mode-only"" rule and a ""locked Shared-Region"" rule with X privileges,
ensure that the relevant pmpcfg field is not updated but is left unchanged,
ensure also that other fields can still get updated.

Cover: M-mode-only / Shared-Region.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgwdata_legal[*].a_cfgwdata_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_rlb_locked_cov[0].a_mmode_only_or_shared_executable_ignore

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_rlb_locked_cov[0].a_mmode_only_or_shared_executable_ignore

COV: (SKIPPED)",Cover skipped because assert is deemed sufficient.
,,ExecRlb,"""[The above] restriction can be temporarily lifted e.g. during the boot process, by setting mseccfg.RLB.""","Have RLB and MML set, try adding an ""M-mode-only"" rule and a ""locked Shared-Region"" rule with X privileges, ensure that the relevant pmpcfg field is in fact updated.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rlblifts_lockedexec[*].a_rlblifts_lockedexec,
,,MmodeExec,"""Executing code with Machine mode privileges is only possible from memory regions with a matching M-mode-only rule or a locked Shared-Region rule with executable privileges. Executing code from a region without a matching rule or with a matching S/U-mode-only rule is denied.""","Execute from ""M-mode-only"" and ""locked Shared-Region"" regions,
attempt execution without matching and from ""U-mode-only"" regions,
ensure corresponding grant or deny.

Cover: The different scenarios.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)",Cover skipped because assert is deemed sufficient.
,,RwReserved,"""If mseccfg.MML is not set, the combination of pmpcfg.RW=01 remains reserved for future standard use.""","Whitelist the conditions that allow RW=01 (including MML conditions), ensure that it is adhered to.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rwx_mml[*].a_rwx_mml

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_rwfuture[*].a_rw_futureuse
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_rwfuture[*].a_rw_futureuse",
,LockdownA,MmodeEnforce,"""[When mseccfg.MML is set.] An M-mode-only rule is enforced on Machine mode""","Be in M-mode,
have MML set,
access an ""M-mode-only"" region,
ensure that the grant/deny is always in accordance to the rule.
(E.g. it is not denied execute despite the execute bit being set.)

Cover: grant / deny for this specific scenario.

Note: Exclude cases of interference from e.g. PMA.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)","(Same as for ""MmodeDeny"")

Cover skipped because assert is deemed sufficient."
,,UmodeDeny,"""[When mseccfg.MML is set.] An M-mode-only rule is [...] denied in Supervisor or User mode.""","Be in U-mode,
have MML set,
access an ""M-mode-only"" region,
ensure that the access is always denied.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: (SKIPPED),Explicit assert skipped in favor of model equivalence checking.
,,RemainLocked,"""[An M-mode-only rule] also remains locked so that any further modifications to its associated configuration or address registers are ignored until a PMP reset""

Certain rules under MML are sticky. They cannot be modified again.","1) Configure for ""M-mode-only,
2) have MML=1 (and RLB=0),
3) ensure that the configs never change again (until reset).

Cover: with mml=1. (Since the assert re-uses a different vplan item's assert.)",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: (See IgnoreWrites)

COV: (SKIPPED)",Cover skipped because assert is deemed sufficient.
,,RlbUnlocks,"""It also remains locked [...] unless mseccfg.RLB is set.""","Have the same setup as in RemainLocked, but let RLB=1, try changing the configs, ensure that they are indeed changed.

Note: ""Assertion check"" includes cover properties.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: (see ""ModifiableEntries"")

COV: (See ""ModifiableEntries"")",
,,UmodeEnforce,"""[When mseccfg.MML is set.] An S/U-mode-only rule is enforced on Supervisor and User modes ""","1) Be in U-mode,
2) have MML=1,
3) access a ""U-mode-only"" region,
4) ensure that the grant/deny is in accordance with the rule (apart from PMA etc).

Cover: Grant / deny.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_cp_data_side.cg_data

COV: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_cp_instr_side.cg_instr

COV: (SKIPPED)","(Same as for ""MmodeDeny"")

Skipped cover for explicit deny, in favor of model equivalence checking."
,,MmodeDeny,"""An S/U-mode-only rule is [...] denied on Machine mode.""","1) Be in M-mode,
2) have MML=1,
3) access a ""U-mode-only"" region,
4) ensure that the access is always denied.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED)",Cover skipped in favor of model equivalence checking.
,,SharedEnforced,"""A Shared-Region rule is enforced on all modes""","1) Be in M-mode and U-mode (separate runs),
2) access a ""Shared-Region"",
3) ensure that the grant/deny is in accordance with the rule.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (See ""UmodeEnforce"").","(Same as for ""MmodeDeny"")"
,,SharedNoexec,"""A Shared-Region rule where pmpcfg.L is not set can be used for sharing data between M-mode and S/U-mode, so is not executable.""","1) Be in M-mode and U-mode,
2) try to execute from ""A Shared-Region rule where pmpcfg.L is not set"",
3) ensure that it does not work (exception).",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (See ""MmodeDeny"").","(Same as for ""MmodeDeny"")"
,,MmodeReadwrite,"""[Shared-Region rule where pmpcfg.L is not set.] M-mode has read/write access to that region""","1) Be in M-mode,
2) perform reads and writes to such a region,
3) ensure that the intended effects happen and that the accesses do not cause exceptions.

Cover: read / write.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (See ""MmodeDeny"").","(Same as for ""MmodeDeny"")"
,,UmodeRead,"""[For a Shared-Region rule where pmpcfg.L is not set] S/U-mode has read access if pmpcfg.X is not set, or read/write access if pmpcfg.X is set.""","Be in U-mode, perform reads and writes to such a region, ensure that the reads always work and that the writes depend on X.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (See ""MmodeDeny"").","(Same as for ""MmodeDeny"")"
,,SharedNowrite,"""A Shared-Region rule where pmpcfg.L is set can be used for sharing code between M-mode and S/U-mode, so is not writeable.""

Note: The spec is unclear here, but ""A Shared-Region rule where pmpcfg.L is set"" must refer to ""LRWX=101X"", because ""The encoding pmpcfg.LRWX=1111"" is a separate point. (This holds for the subsequent items below too.)","Be in M-mode and U-mode, write to such a region, ensure that the writes do not reach the bus and that an exception occurs.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (See ""MmodeDeny"").","(Same as for ""MmodeDeny"")"
,,BothExecute,"""Both M-mode and S/U-mode have execute access on the [Shared-Region rule where pmpcfg.L is set]""","Be in M-mode and U-mode, attempt to execute from such a region, ensure that the code is executed and that the attempt does not cause an exception.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (See ""MmodeDeny"").","(Same as for ""MmodeDeny"")"
,,MmodeRead,"""M-mode also has read access [to Shared-Region rule where pmpcfg.L is set] if pmpcfg.X is set.""","Be in M-mode, attempt to read from such a region, ensure that the success depends accordingly on X.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal
uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (See ""MmodeDeny"").","(Same as for ""MmodeDeny"")"
,,IgnoreUntilReset,"""The [Shared-Region rule where pmpcfg.L is set] remains locked so that any further modifications to its associated configuration or address registers are ignored until a PMP reset, unless mseccfg.RLB is set.""",(Covered by RemainLocked above.),Other,Other,N/A,High Priority,N/A,
,,BothReadonly,"""The encoding pmpcfg.LRWX=1111 can be used for sharing data between M-mode and S/U mode, where both modes only have read-only access to the region.""","Be in M-mode and U-mode, access such a region, ensure that only the reads work and that the rest (write/execute) excepts.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_cp_instr_side.cover_item_covergroup_cg_internals_instr_side_inst_cg_instr_coverpoint_cp_r_mmode_mml_lrwx

COV: dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_cp_data_side.cover_item_covergroup_cg_internals_data_side_inst_cg_instr_coverpoint_cp_r_mmode_mml_lrwx

COV: dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_cp_data_side.cover_item_covergroup_cg_internals_data_side_inst_cg_instr_coverpoint_cp_r_umode_mml_lrwx

COV: (SKIPPED)","Non-exhaustive covers, in favor of model equivalence checking (technically missing the ""the rest … excepts"" cover)."
,,ReadonlyLocked,"""The [pmpcfg.LRWX=1111] rule remains locked so that any further modifications to its associated configuration or address registers are ignored until a PMP reset, unless mseccfg.RLB is set.""",(Covered by RemainLocked above.),Other,Other,N/A,High Priority,N/A,
,LegalRwx,,"Depending on the mseccfg control bits and L, some RWX combinations are reserved.

Note: Use the table from the spec.",Ensure that illegal/reserved mseccfg/L/RWX combinations are unreachable.,Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfg_expected[*].a_cfg_expected

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgwdata_legal[*].a_cfgwdata_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgrdata_expected[*].a_cfgrdata_expected",
,Reachable,,"All legal states in the table are reachable. It could theoretically be that platform-specific constraints made certain states unreachable (particularily related to locking), but we should be able to reach all legal and supported combinations of settings.",Ensure that all legal states are reachable.,Other,Constrained-Random,Functional Coverage,No,"COV: uvmt_cv32e40s_pmp_assert.sv, ""cg_internals_*"".

COV: (SKIPPED)","Cover skipped for all explicit variations of ""denied"", in favor of model equivalence checking."
manual,Parameters,MinimumGranularity,"""The PMP_GRANULARITY parameter is used to configure the minimum granularity of PMP address matching. The minimum granularity is [2^(PMP_GRANULARITY+2)] bytes, so at least 4 bytes.""","Have runs with max granularity, minimum granularity, and something in between. Make sure all checkers/covers are active for each relevant run configuration, so tor/napot/na4 is tested with different granularities.

Cover: cases where a match would otherwise occur but the granularity made the access not match.

Note: Ensure TorMatching etc above heed this parameter.",Other,Constrained-Random,Functional Coverage,No,COV: (SKIPPED),Cover skipped in favor of release-specific configs and the rest of the tests/asserts.
,,NumRegions,"""The PMP_NUM_REGIONS parameter is used to configure the number of PMP regions, starting from the lowest numbered region.""

Note: Including 0 regions.","Have runs with max number, minimum number, and something in between.",Other,Constrained-Random,Functional Coverage,No,COV: (SKIPPED),Cover skipped in favor of release-specific configs.
,,ResetValues,"""The reset value of the PMP CSR registers can be set through the top level parameters PMP_PMPNCFG_RV[], PMP_PMPADDR_RV[] and PMP_MSECCFG_RV.""","Have runs with different reset values. Ensure that after reset then the reset values are effectuated.

Note: Try also, reset values with locked configs.",Assertion Check,"ENV capability, not specific test",Functional Coverage,No,"A: (SKIPPED)

COV: (SKIPPED)",Assert and cover skipped in favor of release-specific configs and integration-level testing.
,,DefaultValues,The reset value defaults should amount to a safe config. (Including no violation of reserved bits.),(Covered by all the checks that handles the various legalities.),Other,Other,N/A,No,N/A,
,CSRs,AlwaysAccessible,"""All PMP CSRs are always implemented"". ""MRW"". The CSRs are M-mode accessible, and their existence does not depend on PMP_NUM_REGIONS.

Note: ""All"" pmp registers, and all fields within them.","1) Be in M-mode,
2) access (reads/writes) all the pmp csrs,
3) ensure that it always works without excepting (because the csrs exist and the mode is appropriate).

Note: Potential overlap with CSR vplan.",Assertion Check,Directed Non-Self-Checking,Assertion Coverage,No,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_always_accessible_mmode_csrs"".",
,,ReservedLegal,"Reserved bits/fields have legal values, matching the platform-specified defaults.","(Overlaps with LegalRwx and RwReservedabove.)
Read all fields of all pmp-related csrs, ensure there are no unsupported values anywhere (at all times).",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_cfgrdata_expected[*].a_cfgrdata_expected,
,,MseccfghZero,"""Hardwired to 0""","Read mseccfgh, ensure it is always 0.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_mseccfgh_zero"".",
,,UnusedZero,"""CSRs (or bitfields of CSRs) related to PMP entries with number PMP_NUM_REGIONS and above are hardwired to zero.""

Note: Including upper parts of pmpcfgn and also pmpaddr.","1) Read pmpcfg and pmpaddr csrs,
2) ensure the values are zero as specified.

Cover: that the other values can be non-zero.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: uvmt_cv32e40s_pmp_assert.sv, ""a_unused_zero_pmp_csrs"".

COV: (SKIPPED).",Cover skipped as not important.
,,Hardening,"Certain CSRs related to the PMP shall be ""hardened"" as per Xsecure.","(CSR hardening is the responsibility of the security features vplan, even the pmp-specific part of it.)",N/A,N/A,N/A,High Priority,N/A,
,MicroArchitecture,WaitUpdate,"Updates to pmp configs should NOT have an effect on earlier instructions (nor on the instruction itself).

Note: Potential security hole.","The pmp grant/deny checking must be compared vs ""rvfi_csr_<csrname>_rdata"".
(This will detect whether the actual pmp decision differs from what the rvfi csr data would incidate.)

Note: Compare ""pc_rdata"" for execute, and ""mem_"" signals for read/write. (Might need additional decoding of ""rvfi_insn"".)",Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_musttrap

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_load

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_store

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_splittrap

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_musttrap

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_cause

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_splittrap",
,,,,"Inject pmp csr write instructions in random testing, intermingled with all other kinds of instructions. This should include random interrupts, bus faults, random bus stalls, etc.",Check against RM,Constrained-Random,Functional Coverage,No,COV: (SKIPPED),Cover skipped because random testing of pmp proved to be low ROI.
,,AffectSuccessors,"Updates to pmp configs MUST have an effect on later instructions.

Note: Potential security hole.

Note: There was a known rtl bug here before (cv32e40s/issues/168).","The ""rvfi_csr_<csrname>_wdata"" (masked) for pmp csrs on one instruction, must match the ""_rdata"" value of the next instruction.
(Combined with checking grant/deny on ""_rdata"", this should ensure that the subsequent instruction has been affected by any pmp csr update.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"(Shares asserts with ""WaitUpdate"" above.)

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rvfi_csr_writes[0].a_rvfi_cfg_writes

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.gen_rvfi_csr_writes[0].a_rvfi_addr_writes",
,,,,(Same random testing as WaitUpdate above.),Other,Other,N/A,No,N/A,
,,ImplementationDetails,"Details about pipeline/prefetcher/bus flushing etc are not part of this vplan. Only black-box observable functional behavior is checked. (Such requirements exists in specs, but are deliberately not addressed here.)",N/A,N/A,N/A,N/A,No,N/A,
,,Performance,Requirements about performance and stalls etc are not covered here (unless review calls for the opposite).,N/A,N/A,N/A,N/A,No,N/A,
,,WriteBuffer,Changes to the pmp config should not impact the write buffer such that a transaction can get its grant/deny status altered.,"Cover cases of the write buffer being full while the pmp cfg changes. Checking of accidental grants is handled by SuppressReq below.
Checking of guaranteed writes is not part of this vplan.

Note: The Write buffer is situated between the pmp and the bus.",Other,Other,Functional Coverage,High Priority,"COV: (See ""WaitUpdate"").",
,Violations,SuppressReq,"When an access is denied by the pmp, the effect is that the attempted obi transaction is suppressed and does not reach the bus.

Note: Both ""instr_req_o"" and ""data_req_o"".","Observe a transaction request coming in to the pmp module, observe the pmp denying the access, ensure that the obi bus is shielded from the transaction request.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.load_store_unit_i.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_supress_req_data.a_suppress_req_data

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.if_stage_i.mpu_i.pmp.pmp_i.u_pmp_assert_if_stage.gen_supress_req_instr.a_suppress_req_instr",
,,InternalBuses,(The transaction request feeding into the mpu and its response signaling is not covered by this vplan.),N/A,N/A,N/A,N/A,No,N/A,
,,ExceptionExecute,"""mcause [...] Instruction access fault [...] Execution attempt with address failing PMP check.""","Attempt execution of a region that pmp denies execution of, ensure that an ""instruction access fault"" exception occurs (read mcause and rvfi signals).

Note: Since ISS can check most of this, one could deprioritize this checking if it is not feasible to check within reasonable efforts. (Same for the next 2 items.)",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_cause,
,,ExceptionLoad,"""mcause [...] Load access fault [...] Load attempt with address failing PMP check.""

Note: Holds for load-reserved too.","1) Attempt loads (and load-reserveds) of a region that pmp denies reading from,
2) ensure that a ""load access fault"" exception occurs (read mcause and rvfi signals).

Cover: normal / load-reserved / pop.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_load

COV: (SKIPPED).","Cover skipped as ""rvfi_if.is_load_instr"" should handle all load types."
,,ExceptionStore,"""mcause [...] Store/AMO access fault [...] Store attempt with address failing PMP check.""

Note: Holds for store-conditional and amo too.","1) Attempt stores (and store-conditionals and amo) to a region that pmp denies writing to,
2) ensure that a ""store/amo access fault"" exception occurs (read mcause and rvfi signals).",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_cause_store

COV: (SKIPPED).","Cover skipped as ""rvfi_if.is_store_instr"" should handle all store types."
,,TrapPrecisely,"""All exceptions are precise"".
Meaning mepc will point to the offending instruction, and exactly previous instructions have their side effects fully visible.

Note: Applies to loads, stores, and executes.","Observe that the pmp causes an exception, ensure that mepc points to the offending instruction.

Note: Let the Exceptions vplan deal with visibility of side effects for earlier instructions.
(Zc push/pop does not follow this, but that is mostly the responsibility of the Zc vplan.)

Note: If satisfactory mepc checking already exist then it is acceptable to just add covers for the pmp scenarios.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: (SKIPPED).

COV: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noexec_cause"".

COV: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noloadstore_cause_load"".

COV: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noloadstore_cause_store"".","Assertion skipped because 1) we don't have readily-available helper signals for non-clic pointers, and 2) this is not a high priority assert. (It could be easy to write and assert that mepc is pc_rdata, with some exceptions to that rule.)"
,,AlertMinor,"""The following issues result in a minor security alert: [...] Instruction access fault [...] Load access fault [...] Store/AMO access fault""",(Responsibility of the xsecure vplan. But link to coverage here too.),N/A,N/A,N/A,High Priority,"A: uvmt_cv32e40s_xsecure_security_alerts_assert.sv, ""a_xsecure_security_alert_non_nmi_exceptions"".

COV: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noexec_cause"".

COV: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noloadstore_cause_load"".

COV: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noloadstore_cause_store"".",Waiting for xsecure vplan
,,AlertNothing,"The manual lists which pmp-related events can cause an alert minor, but the pmp should in no other cases be the cause for an alert (major/minor).

Note: Example, ""attempt to reprogram a locked PMP""","Observe an alert signal going high while there is no pmp error that should have caused it, ensure that another viable reason for the alert was present.

Note: This is slightly out of scope for this vplan, so if it is not very easy to hook on to existing xsecure (helper-)signals then this can be skipped.",Assertion Check,Constrained-Random,Assertion Coverage,No,A: (SKIPPED).,Assert skipped in favor of deeming the xsecure verification and integration-level testing sufficient.
,,SplitLoadRegfile,"Even if parts of a split load can reach the bus, the instruction itself has failed and so the regfile should not get updated.","(Handled by ""SplitLoadException"" below, because: One only needs to show that an exception is caused, and the exceptions vplan is responsible for checking what that means for the regfile. (But link to coverage here too.))",N/A,N/A,N/A,No,"A: uvmt_cv32e40s_rvfi_assert.sv, ""a_exceptions_dont_update_gprs"".",
,,SplitLoadException,"For split loads, regardless of which of the access that fails, the instruction should still cause an exception.","1) Perform a misaligned load that translates to multiple accesses,
2) let any of the accesses be denied by pmp,
3) ensure an exception occurs.

Coverage: See rvfi retire with exception cause from pmp, while the ""low addr"" model checking gave access granted.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noloadstore_splittrap"".","Note: The assert only checks that the 2nd access is denied, not the general case of _any_."
,,FirstFail,"If a split load/store fails on its first transaction it should get an exception immediately, so it should not allow the second transaction reach the bus and mcause shall reflect the failing transactions.","1 Attempt such an instruction,
2) ensure that the denied access does not reach the bus,
3) ensure that following accesses also do not reach the bus.

Cover: load / store.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_rvfi_mem_allowed_data"".

A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_rvfi_mem_allowed_upperdata"".",Note: Trusting RVFI to report OBI actuals truthfully.
,,PushPop,"If a push/pop fails on a transaction it should get an exception immediately, so the remaining transactions should not reach the bus and mcause shall reflect the failing transaction.","(Responsibility of the zc vplan. But link to coverage here too.)

Cover: could write a pmp-specific cover, but coordinate with Zc vplan to ensure the checker is written too.",N/A,N/A,N/A,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.u_zc_assert.a_multiop_exception_stop_dbus_push

A: A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.u_zc_assert.a_multiop_exception_stop_dbus_pop

COV: (SKIPPED).",Cover skipped in favor of trusting that formal will exercise the assert for pmp-specific cases.
,,TableJump,PMP applies to table jumps and Zc instructions in general.,"(Responsibility of the zc vplan. But link to coverage here too.)

Note: Could write a pmp-specific cover, but coordinate with Zc vplan to ensure the checker is written too.",N/A,N/A,N/A,High Priority,"A: (SKIPPED).

COV: (SKIPPED).",Assert and cover skipped in favor of trusting that formal will exercise the assert for pmp-specific cases.
,,ClicVector,"Similarly to TableJump above, CLIC vector fetch needs execute permission.",(Analogous to TableJump above.),N/A,N/A,N/A,High Priority,"A: ???

COV: ???",TODO Waiting for clic vplan
,,Priority,"Exceptions priority apply to the PMP as well. Particularily, PMP exception (instruction access fault) gets priority over bus errors (instruction bus fault) if an instruction is the result of two fetches were both of these occurred.

Note: Both could be present in an attempted executed instruction at the same time, because no exception occurs before the point of execution so there is enough time for both to be captured and travel through the pipeline.","1) Keep track of words fetched with bus error and with pmp execute denied,
2) check retired instructions for a pc that overlaps two such fetches (cover both orders),
3) ensure that ""instruction access fault"" is the taken exception.",Assertion Check,Constrained-Random,Functional Coverage,No,"A: (SKIPPED).

COV: (SKIPPED).","Assert and cover skipped because it would require support logic with an unreasonably low ROI, and we have other exceptions checking."
,Pma,RevokeExecutable,"Even if the pma should allow for execution, the pmp can overrule it and deny access.","Set up pma and pmp regions such that both have rules covering the same addresses, let the pma allow for execution, let the pmp deny it, attempt execution, ensure that execution is indeed denied.",Assertion Check,Constrained-Random,Assertion Coverage,No,A: (SKIPPED).,Assert skipped in favor of regarding the pmp and pma efforts themselves as sufficient.
,,RemainNonexecutable,"If the pma disallows execution, the pmp cannot change this fact and execution remains disallowed.","Set up pma and pmp regions such that both have rules covering the same addresses, let the pma disallow execution, let the pmp allow and deny execution (separate runs), attempt execution, ensure that execution is denied.",Assertion Check,Constrained-Random,Assertion Coverage,No,A: (SKIPPED).,Assert skipped in favor of regarding the pmp and pma efforts themselves as sufficient.
,,RevokePermissible,"Even if the pma allows for data access, the pmp can overrule it and deny access.","Set up pma and pmp regions such that both have rules covering the same addresses, let the pma allow for read and write (separate or same runs), let pmp deny read/write, attempt read/write, ensure that the pmp can overrule the pma.",Assertion Check,Constrained-Random,Assertion Coverage,No,A: (SKIPPED).,Assert skipped in favor of regarding the pmp and pma efforts themselves as sufficient.
,,RemainNonpermissible,"If the pma disallows data access, the pmp cannot change this fact and data access remains disallowed.","Set up pma and pmp regions such that both have rules covering the same addresses, let the pma deny read and write, let pmp allow or deny it, attempt read/write, ensure that the access is always denied.",Assertion Check,Constrained-Random,Assertion Coverage,No,A: (SKIPPED).,Assert skipped in favor of regarding the pmp and pma efforts themselves as sufficient.
,,DisallowDebug,"""As execution based debug is used, the Debug Module region, as defined by the DM_REGION_START and DM_REGION_END parameters, needs to support code execution, loads and stores when CV32E40S is in debug mode. In order to achieve this CV32E40S overrules the PMA and PMP settings for the Debug Module region when it is in debug mode (see Physical Memory Attribution (PMA) and Physical Memory Protection (PMP)).""","Check that accesses to the DM region are never blocked.

Cover: access within range, would deny / allow.",Assertion Check,Directed Non-Self-Checking,Assertion Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_accept_only_legal

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.core_i.*.mpu_i.pmp.pmp_i.u_pmp_assert_lsu.gen_pmp_assert.a_deny_only_illegal

COV: (SKIPPED).",Cover skipped in favor of trusting that formal will exercise the assert for dm region specific cases.
misc,Misc,40x,The 40x does not have PMP.,N/A,N/A,N/A,N/A,No,N/A,
,,Xif,"The X-interface can do memory operations, but the 40x does not have PMP and the 40s does not have XIF.",N/A,N/A,N/A,N/A,No,N/A,
,,RvfiReliable,"Rvfi is used for checking some pmp functionality, so the link between rvfi and pmp must be checked.","If feasible to model within reasonable effort, check that 1) the PMPs' privmode inputs and 2) CSRs and 3) wdata/wmask is for csr write instrs, are properly correlated between access attempts and rvfi reportings.
Otherwise, leave this to general ISS checking.",Assertion Check,"ENV capability, not specific test",Assertion Coverage,No,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*

(Indirectly checked by those asserts)",
,,RvfiTrap,"The ""rvfi_trap"" table has PMP-specific fields.","Augment the exception checkers above with checking of ""rvfi_trap.cause_type"" to ensure that specifically PMP is reported as the cause.
E.g. ""|-> rvfi_trap"" changed to ""|-> rvfi_trap && <cause equal to …>"".",Assertion Check,"ENV capability, not specific test",Assertion Coverage,No,"A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noexec_cause"".

A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noloadstore_cause_load"".

A: uvmt_cv32e40s_pmprvfi_assert.sv, ""a_noloadstore_cause_store"".",
,,UntilReset,"Everything that can get locked ""until reset"" must be possible to change after a reset. It should not be possible that these settings lock up so even resets cannot unlock them.

Note: Formal's reset analysis should in principle be able to find every state that is possible to be in after a reset.","(Covered by ResetValues above. As long as those always take effect out of reset, then a permanent lock up should be either impossible or intentional.)",N/A,N/A,N/A,No,N/A,
,,Xsecure,(Will be covered by its own vplan.),N/A,N/A,N/A,N/A,High Priority,N/A,
,,Reset,The PMP module is never reset without the whole core being reset. (As this could lift all the locks and stickies and grant privilege escalation.),Check that the core's reset is always equal to the pmp module's reset.,Assertion Check,"ENV capability, not specific test",Assertion Coverage,No,A: (SKIPPED).,"Skipped in favor of trusting ""WaitUpdate"" and ""AffectSuccessors"" and all other functional asserts.."
,,UmodeZeroRegions,"If the parameters are set to have 0 pmp regions, then all rules are OFF and U-mode matches nothing and defaults to not have any access.","Be in U-mode, have PMP_NUM_REGIONS=0, ensure all accesses fail (read/write/execute).

Note: also assert that read/write attempts can not occur.",Assertion Check,Constrained-Random,Assertion Coverage,High Priority,A: (SKIPPED).,Skipped in favor of using realease-specific configs.
debug,Mmode,,"""All operations are executed with machine mode privilege"".
It is mostly the responsibility of other vplans to check D-mode relationship to M-mode and U-mode, but the pmp inputs should be checked against debug mode.

Note: Refer to user-mode vplan and debug vplan if necessary.

Note: It is assumed that once 1) dmode is shown to be interpreted as mmode by pmp, and 2) all mmode features are verified, then C) the mmode features will work in dmode. But one alternative is to duplicate all the mmode-related checking with dmode variants.","Ensure that the PMP inputs receive the correct mode while in D-mode.

Cover: w/wo MPRV.",Assertion Check,Constrained-Random,Functional Coverage,High Priority,"A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noexec_*

A: uvmt_cv32e40s_tb.dut_wrap.cv32e40s_wrapper_i.rvfi_i.pmprvfi_assert_i.a_noloadstore_*

(Indirectly checked by those asserts, together with effective priv mode and umode asserts for dmode/mmode.)

COV: (SKIPPED).","Cover skipped because the asserts are deemed sufficient, and because debug has its own new override mechanism."
